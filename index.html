<!DOCTYPE HTML>
<html>
<head>
	<script src="https://code.jquery.com/jquery-1.10.2.js"></script>
</head>
<style>
    @font-face {
        font-family: visitor;
        src: url("assets/visitor1.ttf");
    }
</style>
<body bgcolor="#787878">
<canvas id="myCanvas" height="144" width="160" style="border:1px solid black; display:none"></canvas>
<canvas id="rendCanvas" height="144" width="160" style="border:1px solid black; image-rendering: pixelated;"></canvas>
<canvas id="loadCanvas" height="256" width="256" style="border:1px solid black; display:none"></canvas>

<script type="text/javascript">
    //music url http://www.beepbox.co/#5s6k6l00e0ftaa7g0fj7i0r0w1111f0000d1111c0000h0060v0003o3210b000w8h4h4g0h4i4zcP8x8y8y4h8y8h8h4x800i4w018p22-FBO9cd6gFO0V6j8Rj3Apllg5cKh9xwQQV0siN2hGMoIOSD83ApdteyCNd3HqTqWwkOV4C6z8kV0sz9AqGqfuPnjIp5dehjAQQwmo589wngChmNmRhJr5rl6QVwhmYnBulZltunI2XR2TvgHKXU_cPcHKXHKXM3dgggA444aXKY-O0Xi7dQrmlhhthhJkm0
    var blink = true;			//state of blink
    var frames = 0;				//A frame count
    var goalTile = {x:-1,y:-1};	//Exit Tile	
    var lvlComplete = false;	//Status of competion
	var canvasHeight = 576;
	var canvasWidth = 640;
    var screenWidth = 160;		//Game Resolution Width
    var screenHeight = 144;		//Game Resolution Height
	var tileSize = 8;			//size of tiles
	var scaleFactor = 5;			//screen scaling factor
    var lvlWidth = screenWidth/tileSize;		//width of room
    var lvlHeight = (screenHeight/tileSize)-2;	//height of room
	var sheetWidth = 256;		//width and height of sprite sheet
    var points = 0;				//count of points
    var cards = [];				//List of coin objects
    var moves = 0;				//count of moves
	var search = [];			//list of connected tiles
    var fps = 60;					//count of frames per second
	var pressedKeys = [];		//list of accepted key presses at a given time
    var hasAug = -1;
    var difficulty = 1;
	var paused = false;
    var depth = -1;
    var menuHeight = screenHeight-16;
    var menu = false;
    var rTransition = -1;
    var roomDrawY = 0;
    var roomDrawX = 0;
    var currLvl;
    var prevLvl;
    var wallSet = 0;
    var bannerCounter = 0;
    var palette = false;
    var rendScreen;
    var img;
    var spriteMap = [];
    var sX,sY,imgData,curimg;
    var remKeys = 0;
    var remMobs = 0;
    var draws = 0;
    var drawsperframe = 0;
    var palettesEnabled = true;
	
    var spriteSheet = new Image();	//Sheet of sprite images
	spriteSheet.src = 'assets/char_sheet.png';
    
    var playerSheet = new Image();
    playerSheet.src = 'assets/player_sheet.png';
	
	var roomTemplates = new Image();
	roomTemplates.src = 'assets/RoomTemplates.png';
    
    var bgm = new Audio('assets/song2.wav');
    
    var currPal;
    var pal_0 = [[241,241,241,255],[178,178,178,255],[108,108,108,255],[26,26,26,255]];
    var pal_1 = [[241,241,241,255],[216,184,248,255],[104,136,252,255],[26,26,26,255]];
    var pal_2 = [[241,241,241,255],[88,216,84,255],[0,232,216,255],[26,26,26,255]];
    var pal_3 = [[241,241,241,255],[248,184,0,255],[216,0,204,255],[26,26,26,255]];
    var pal_4 = [[241,241,241,255],[0,232,216,255],[252,160,68,255],[26,26,26,255]];
    
    var pal_5 = [[241,241,241,255],[88,1216,84,255],[0,184,0,255],[26,26,26,255]];
    var pal_6 = [[241,241,241,255],[248,120,88,255],[168,16,0,255],[26,26,26,255]];
    var pal_7 = [[241,241,241,255],[60,188,252,255],[0,136,136,255],[26,26,26,255]];
    var pal_8 = [[241,241,241,255],[248,184,0,255],[172,124,0,255],[26,26,26,255]];
    var pal_9 = [[241,241,241,255],[152,120,248,255],[148,0,132,255],[26,26,26,255]];
    var pal_10 = [[241,241,241,255],[184,248,184,255],[88,216,84,255],[26,26,26,255]];
    var pal_11 = [[241,241,241,255],[248,120,248,255],[228,0,88,255],[26,26,26,255]];
    var pal_12 = [[241,241,241,255],[252,124,168,255],[248,124,0,255],[26,26,26,255]];
    
    var pals = [pal_0,pal_1,pal_2,pal_3,pal_4,pal_5,pal_6,pal_7,pal_8,pal_9,pal_10,pal_11,pal_12];
    
    currPal = pals[0];
    
    var sets = [0,6];
    
    wallSet = sets[0];
    
    //initiate canvas
	var canvas = document.getElementById("myCanvas");
	var ctx = canvas.getContext("2d");
	ctx.imageSmoothingEnabled = false;
    
    var loadCanvas = document.getElementById('loadCanvas');
    var lctx = loadCanvas.getContext("2d");
    lctx.imageSmoothingEnabled = false;
    
    lctx.fillStyle = 'black';
    lctx.fillRect(0,0,256,256);
    
    var rendCanvas = document.getElementById("rendCanvas");
	var rctx = rendCanvas.getContext("2d");
    
    var map = [[]];
    var mapLoc = {x:0, y:0};
    
    var minimap = { display:false, 
                    map:[],
                    update: function() {
                                var newRow = [];
                                minimap.map = [];
                                for (var i=0; i<map.length; i++) {
                                    newRow = [];
                                    for (var j=0; j<map[i].length; j++) {
                                        newRow.push(map[i][j].mini);
                                    }
                                    minimap.map.push(newRow);
                                }
                            }   
    };
    
    var player={x:9*tileSize,
                y:8*tileSize,
                drawX: 9*tileSize,
                drawY: 9*tileSize,
                dir:2,
                strafe: false,
                moving: false,
                attacking: false,
                invincible: false,
                invincCounter: 0,
                invincLimit:60,
                moveWhileAttacking: false,
                speed: 1,//60/fps,
                speedLimit: 4,
                base_damage:1,
                base_defense:1,
                health:10,
                healthGen:0,
                maxHealth:10,
                healthLimit:32,
                spirit:10,
                spiritGen:.1,
                maxSpirit:10,
                spiritLimit:32,
                curse:0,
                curseGen:.0001,
                maxCurse:10,
                exp:0,
                lvlUp: 5,
                lvl:0,
                newLvl:10,
                augments:[],
				maxAugs: 5,
                headSet: 0,
                bodySet: 0,
                animations:{wU_anim:[{x:48,y:24,dur:4},{x:32,y:24,dur:4},{x:64,y:24,dur:4},{x:32,y:24,dur:4}],
                            wD_anim:[{x:48,y:0,dur:4},{x:32,y:0,dur:4},{x:64,y:0,dur:4},{x:32,y:0,dur:4}],
                            wL_anim:[{x:48,y:16,dur:4},{x:32,y:16,dur:4},{x:64,y:16,dur:4},{x:32,y:16,dur:4}],
                            wR_anim:[{x:48,y:8,dur:4},{x:32,y:8,dur:4},{x:64,y:8,dur:4},{x:32,y:8,dur:4}],
                            aU_anim:[{x:80,y:24,dur:1},{x:96,y:24,dur:1},{x:112,y:24,dur:8}],
                            aD_anim:[{x:80,y:0,dur:1},{x:96,y:0,dur:1},{x:112,y:0,dur:8}],
                            aL_anim:[{x:80,y:16,dur:1},{x:96,y:16,dur:1},{x:112,y:16,dur:8}],
                            aR_anim:[{x:80,y:8,dur:1},{x:96,y:8,dur:1},{x:112,y:8,dur:8}]
                            },
                anim_index:0,
                animCounter:-1,
                update: function (){
                            
                            if (this.freeRoam == true) {
                                this.drawX = this.x;
                                this.drawY = this.y;
                            } else {
                                this.drawX = 9*tileSize;
                                this.drawY = 8*tileSize;
                            }
                            
                            if (this.invincible == true) {
                                this.invincCounter++;
                            }
                            
                            if (this.invincCounter > this.invincLimit) {
                                this.invincible = false;
                                this.invincCounter = 0;
                            }
                            
                            if (this.speed > 4) {
                                this.speed = 4;
                            }
                            
                            //regen(?) health
                            this.health+=this.healthGen;
                            if (this.health > this.maxHealth) {
                                this.health = this.maxHealth;
                            }
                            
                            //progress curse
                            this.curse+=this.curseGen;
                            if (this.curse > this.maxCurse) {
                                this.curse = this.maxCurse;
                            }
                            
                            //check on level progression
                            if (this.exp == this.newLvl) {
                                this.lvl++;
                                this.exp = 0;
                                this.maxHealth = this.maxHealth+this.lvlUp;
                                if (this.maxHealth > this.healthLimit) {
                                    this.maxHealth = this.healthLimit;
                                }
                                this.health = this.maxHealth;
                                this.maxSpirit = this.maxSpirit+this.lvlUp;
                                if (this.maxSpirit > this.spiritLimit) {
                                    this.maxSpirit = this.spiritLimit;
                                }
                                //diminishing returns of level ups
                                this.lvlUp = Math.ceil(this.lvl/2);
                            }
                            
                            //check if player should be moving
                            if (pressedKeys.indexOf('W') > -1 || pressedKeys.indexOf('A') > -1 ||
                                pressedKeys.indexOf('S') > -1 || pressedKeys.indexOf('D') > -1) {
                                
                                this.moving = true;
                                if (this.animCounter == -1) {
                                    this.animCounter = 0;
                                }
                            } else {
                                this.moving = false;
                            }
                            
                            //check if/where the player should be facing
                            if (pressedKeys.indexOf('J') > -1) {
                                this.strafe = true;
                            } else {
                                this.strafe = false;
                            }
                            
                            //use weapon or regen spirit
                            if (this.attacking == true) {
                                if (this.moveWhileAttacking == false) {
                                    this.moving  = false;
                                }
                                if (this.weapons[this.wepIndex].cont == false && this.weapons[this.wepIndex].swung == false) {
                                    this.weapons[this.wepIndex].action();
                                } else if (this.weapons[this.wepIndex].cont == true) {
                                    this.weapons[this.wepIndex].action();
                                }
                                
                                if (this.animCounter == -1) {
                                    this.animCounter = 0;
                                    this.anim_index = 0;
                                }
                            } else {
                                this.spirit = this.spirit+this.spiritGen;
                            }
                            
                            if (pressedKeys.indexOf('_') < 0 && this.weapons[this.wepIndex].swung == true) {
                                this.weapons[this.wepIndex].swung = false;
                            }
                            
                            //update the weapon
                            this.weapons[this.wepIndex].update();
                            
                            if (this.spirit > this.maxSpirit) {
                                this.spirit = this.maxSpirit;
                            }
                            
                            if (this.moving == false && this.attacking == false) {
                                this.animCounter = -1;
                            }
                            
                            for (var i=0; i<pressedKeys.length; i++) {
                                switch (pressedKeys[i]) {
                                    case    'W':    if (this.moving == true) {
                                                        this.move(0);
                                                    }
                                                    break;
                                    case    'A':    if (this.moving == true) {
                                                        this.move(1);
                                                    }
                                                    break;
                                    case    'S':    if (this.moving == true) {
                                                        this.move(2);
                                                    }
                                                    break;
                                    case    'D':    if (this.moving == true) {
                                                        this.move(3);
                                                    }
                                                    break;
									case	'_':	if (this.attacking == false && this.spirit>=this.weapons[this.wepIndex].init_cost && this.weapons[this.wepIndex].swung == false) {
                                                        this.anim_index = 0;
                                                        this.attacking = true;
                                                        this.spirit = this.spirit-this.weapons[this.wepIndex].init_cost;
                                                    }
                                                    if (this.attacking == true && player.weapons[this.wepIndex].cont == true){
                                                        this.spirit = this.spirit-player.weapons[this.wepIndex].use_cost;
                                                        if (this.spirit < -1) {
                                                            this.attacking = false;
                                                            this.spirit = -1;
                                                        }
                                                    }
                                                    
													break;
                                }
                            }
                        },
                move:   function (dir) {
                            if (dir == 0) {
                                if (this.strafe == false) {
                                    this.dir = 0;
                                }
                                var canMove = this.speed;
                                if (this.y-this.speed <= 0) {
                                    canMove = 0 - (this.y-this.speed);
                                    if (canMove < 0) {
                                        canMove = 0;
                                    }
                                    this.y-=canMove;
                                } else {
                                    canMove =  .25;
                                    while (canMove <= this.speed) {
                                        if (currLvl[1][Math.floor((this.y-(.25))/8)][Math.floor(Math.floor(this.x)/8)] ==0 &&
                                            currLvl[1][Math.floor((this.y-(.25))/8)][Math.ceil(Math.ceil(this.x)/8)] ==0) {
                                            this.y-=.25;
                                        } else {
                                            break;
                                        }
                                        canMove+=.25;
                                    }
                                }
                                
                            }
                            if (dir == 1) {
                                if (this.strafe == false) {
                                    this.dir = 1;
                                }
                                var canMove = this.speed;
                                if (this.x-this.speed <= 0) {
                                    canMove = 0 - (this.x-this.speed);
                                    if (canMove < 0) {
                                        canMove = 0;
                                    }
                                    this.x-=canMove;
                                } else {
                                    canMove = .25;
                                    while (canMove <= this.speed) {
                                        if (currLvl[1][Math.floor((Math.floor(this.y))/8)][Math.floor((this.x-.25)/8)] == 0 &&
                                            currLvl[1][Math.ceil(((Math.ceil(this.y)))/8)][Math.floor((this.x-.25)/8)] == 0) {
                                            
                                            this.x-=.25;
                                        } else {
                                            break;
                                        }
                                        canMove+=.25;
                                    }
                                }
                                
                            }
                            if (dir == 2) {
                                if (this.strafe == false) {
                                    this.dir = 2;
                                }
                                var canMove = this.speed;
                                if (this.y+this.speed+8 >= screenHeight-16) {
                                    canMove = (this.y+this.speed) - screenHeight-16;
                                    if (canMove < 0) {
                                        canMove = 0;
                                    }
                                    this.y+=canMove;
                                } else {
                                    canMove = .25;
                                    while (canMove <= this.speed) {
                                        if (currLvl[1][Math.ceil((this.y+.25)/8)][Math.floor(Math.floor(this.x)/8)] == 0 &&
                                            currLvl[1][Math.ceil((this.y+.25)/8)][Math.ceil(Math.ceil(this.x)/8)] == 0) {
                                            
                                            this.y+=.25;
                                        } else {
                                            break;
                                        }
                                        canMove+=.25;
                                    }
                                }
                                
                            }
                            if (dir == 3) {
                                if (this.strafe == false) {
                                    this.dir = 3;
                                }
                                var canMove = this.speed;
                                if (this.x+this.speed+8 >= screenWidth) {
                                    canMove = (this.x+this.speed) - screenWidth;
                                    if (canMove < 0) {
                                        canMove = 0;
                                    }
                                    this.x+=canMove;
                                } else {
                                    canMove = .25;
                                    while (canMove <= this.speed) {
                                        if (currLvl[1][Math.ceil(Math.ceil(this.y)/8)][Math.ceil((this.x+.25)/8)] == 0 &&
                                            currLvl[1][Math.floor(Math.floor(this.y)/8)][Math.ceil((this.x+.25)/8)] == 0) {
                                        
                                            this.x+=.25;
                                        } else {
                                            break;
                                        }
                                        canMove+=.25;
                                    }
                                }
                            }
                        },
                draw:   function(){
                            
                            if (this.invincCounter%2 == 0) {
                            
                                if (this.dir == 0) {
                                    if (this.moving == true && paused == false) {
                                        if (this.animCounter > -1) {
                                            this.animCounter++;
                                            if (this.animCounter > this.animations.wU_anim[this.anim_index].dur) {
                                                this.animCounter = 0;
                                                this.anim_index++;
                                                if (this.anim_index >= this.animations.wU_anim.length) {
                                                    this.anim_index = 0;
                                                }
                                            }
                                        }
                                        
                                        ctx.drawImage(playerSheet, 16,0+this.bodySet,16,16,this.x-4, this.y-15,16,16);
                                        ctx.drawImage(playerSheet, this.animations.wU_anim[this.anim_index].x,this.animations.wU_anim[this.anim_index].y+this.bodySet,16,8,this.x-4, this.y,16,8);
                                        for (var i=0; i<this.augments.length; i++) {
                                            ctx.drawImage(playerSheet, 144,0+this.augments[i].drawCol,16,16,this.x-4, this.y-15,16,16);
                                            ctx.drawImage(playerSheet, 128+this.animations.wU_anim[this.anim_index].x,this.animations.wU_anim[this.anim_index].y+this.augments[i].drawCol,16,8,this.x-4, this.y,16,8);
                                        }
                                    } else if (this.attacking == true && paused == false){
                                        if (this.animCounter > -1) {
                                            this.animCounter++;
                                            if (this.animCounter > this.animations.aU_anim[this.anim_index].dur) {
                                                this.animCounter = 0;
                                                this.anim_index++;
                                                if (this.anim_index >= this.animations.aU_anim.length) {
                                                    this.anim_index = 0;
                                                }
                                            }
                                        }
                                        
                                        
                                        ctx.drawImage(playerSheet, 16,0+this.bodySet,16,16,this.x-4, this.y-15,16,16);
                                        ctx.drawImage(playerSheet, this.animations.aU_anim[this.anim_index].x,this.animations.aU_anim[this.anim_index].y+this.bodySet,16,8,this.x-4, this.y,16,8);
                                        
                                    } else {
                                        ctx.drawImage(playerSheet, 16,0+this.bodySet,16,16,this.x-4, this.y-16,16,16);
                                        ctx.drawImage(playerSheet, 32,24+this.bodySet,16,8,this.x-4, this.y,16,8);
                                        for (var i=0; i<this.augments.length; i++) {
                                            ctx.drawImage(playerSheet, 128+16,0+this.augments[i].drawCol,16,16,this.x-4, this.y-16,16,16);
                                            ctx.drawImage(playerSheet, 128+32,24+this.augments[i].drawCol,16,8,this.x-4, this.y,16,8);
                                        }
                                    }
                                    
                                }
                                if (this.dir == 1) {
                                    if (this.moving == true && paused == false) {
                                        if (this.animCounter > -1) {
                                            this.animCounter++;
                                            if (this.animCounter > this.animations.wL_anim[this.anim_index].dur) {
                                                this.animCounter = 0;
                                                this.anim_index++;
                                                if (this.anim_index >= this.animations.wL_anim.length) {
                                                    this.anim_index = 0;
                                                }
                                            }
                                        }
                                        
                                        ctx.drawImage(playerSheet, this.animations.wL_anim[this.anim_index].x,this.animations.wL_anim[this.anim_index].y+this.bodySet,16,8,this.x-4, this.y,16,8);
                                        ctx.drawImage(playerSheet, 0,16+this.bodySet,16,16,this.x-4, this.y-15,16,16);
                                        for (var i=0; i<this.augments.length; i++) {     
                                            ctx.drawImage(playerSheet, 128+this.animations.wL_anim[this.anim_index].x,this.animations.wL_anim[this.anim_index].y+this.augments[i].drawCol,16,8,this.x-4, this.y,16,8);
                                            ctx.drawImage(playerSheet, 128+0,16+this.augments[i].drawCol,16,16,this.x-4, this.y-15,16,16);
                                        }
                                    } else if (this.attacking == true && paused == false){
                                        if (this.animCounter > -1) {
                                            this.animCounter++;  
                                            if (this.animCounter > this.animations.aL_anim[this.anim_index].dur) {
                                                this.animCounter = 0;
                                                this.anim_index++;
                                                if (this.anim_index >= this.animations.aL_anim.length) {
                                                    this.anim_index = 0;
                                                }
                                            }
                                        }
                                        
                                        ctx.drawImage(playerSheet, this.animations.aL_anim[this.anim_index].x,this.animations.aL_anim[this.anim_index].y+this.bodySet,16,8,this.x-4, this.y,16,8);
                                        ctx.drawImage(playerSheet, 0,16+this.bodySet,16,16,this.x-4, this.y-15,16,16);
                                    } else {
                                        ctx.drawImage(playerSheet, 0,16+this.bodySet,16,16,this.x-4, this.y-16,16,16);
                                        ctx.drawImage(playerSheet, 32,16+this.bodySet,16,8,this.x-4, this.y,16,8);
                                        for (var i=0; i<this.augments.length; i++) {     
                                            ctx.drawImage(playerSheet, 128+0,16+this.augments[i].drawCol,16,16,this.x-4, this.y-16,16,16);
                                            ctx.drawImage(playerSheet, 128+32,16+this.augments[i].drawCol,16,8,this.x-4, this.y,16,8);
                                        }
                                    }
                                    
                                }
                                if (this.dir == 2) {
                                    if (this.moving == true && paused == false) {
                                        if (this.animCounter > -1) {
                                            this.animCounter++;
                                            if (this.animCounter > this.animations.wD_anim[this.anim_index].dur) {
                                                this.animCounter = 0;
                                                this.anim_index++;
                                                if (this.anim_index >= this.animations.wD_anim.length) {
                                                    this.anim_index = 0;
                                                }
                                            }
                                        }
                                        
                                        ctx.drawImage(playerSheet, this.animations.wD_anim[this.anim_index].x,this.animations.wD_anim[this.anim_index].y+this.bodySet,16,8,this.x-4, this.y,16,8);
                                        ctx.drawImage(playerSheet, 0,0+this.bodySet,16,16,this.x-4, this.y-15,16,16);
                                        for (var i=0; i<this.augments.length; i++) {     
                                            ctx.drawImage(playerSheet, 128+this.animations.wD_anim[this.anim_index].x,this.animations.wD_anim[this.anim_index].y+this.augments[i].drawCol,16,8,this.x-4, this.y,16,8);
                                            ctx.drawImage(playerSheet, 128+0,0+this.augments[i].drawCol,16,16,this.x-4, this.y-15,16,16);
                                        }
                                    } else if (this.attacking == true && paused == false){
                                        if (this.animCounter > -1) {
                                            this.animCounter++;
                                            if (this.animCounter > this.animations.aD_anim[this.anim_index].dur) {
                                                this.animCounter = 0;
                                                this.anim_index++;
                                                if (this.anim_index >= this.animations.aD_anim.length) {
                                                    this.anim_index = 0;
                                                }
                                            }
                                        }
                                        
                                        ctx.drawImage(playerSheet, this.animations.aD_anim[this.anim_index].x,this.animations.aD_anim[this.anim_index].y+this.bodySet,16,8,this.x-4, this.y,16,8);
                                        ctx.drawImage(playerSheet, 0,0+this.bodySet,16,16,this.x-4, this.y-15,16,16);
                                    } else {
                                        ctx.drawImage(playerSheet, 0,0+this.bodySet,16,16,this.x-4, this.y-16,16,16);
                                        ctx.drawImage(playerSheet,32,0+this.bodySet,16,8,this.x-4, this.y,16,8);
                                        for (var i=0; i<this.augments.length; i++) {     
                                            ctx.drawImage(playerSheet, 128+32,0+this.augments[i].drawCol,16,8,this.x-4, this.y,16,8);
                                            ctx.drawImage(playerSheet, 128+0,0+this.augments[i].drawCol,16,16,this.x-4, this.y-16,16,16);
                                        }
                                    }
                                }
                                if (this.dir == 3) {
                                    if (this.moving == true && paused == false) {   
                                        if (this.animCounter > -1) {
                                            this.animCounter++;
                                            if (this.animCounter > this.animations.wR_anim[this.anim_index].dur) {
                                                this.animCounter = 0;
                                                this.anim_index++;
                                                if (this.anim_index >= this.animations.wR_anim.length) {
                                                    this.anim_index = 0;
                                                }
                                            }
                                        }
                                        
                                        ctx.drawImage(playerSheet, this.animations.wR_anim[this.anim_index].x,this.animations.wR_anim[this.anim_index].y+this.bodySet,16,8,this.x-4, this.y,16,8);
                                        ctx.drawImage(playerSheet, 16,16+this.bodySet,16,16,this.x-4, this.y-15,16,16);
                                        for (var i=0; i<this.augments.length; i++) {     
                                            ctx.drawImage(playerSheet, 128+this.animations.wR_anim[this.anim_index].x,this.animations.wR_anim[this.anim_index].y+this.augments[i].drawCol,16,8,this.x-4, this.y,16,8);
                                            ctx.drawImage(playerSheet, 128+16,16+this.augments[i].drawCol,16,16,this.x-4, this.y-15,16,16);
                                        }
                                    } else if (this.attacking == true && paused == false){
                                        if (this.animCounter > -1) {
                                            this.animCounter++;
                                            if (this.animCounter > this.animations.aR_anim[this.anim_index].dur) {
                                                this.animCounter = 0;
                                                this.anim_index++;
                                                if (this.anim_index >= this.animations.aR_anim.length) {
                                                    this.anim_index = 0;
                                                }
                                            }
                                        }
                                        
                                        ctx.drawImage(playerSheet, this.animations.aR_anim[this.anim_index].x,this.animations.aR_anim[this.anim_index].y+this.bodySet,16,8,this.x-4, this.y,16,8);
                                        ctx.drawImage(playerSheet, 16,16+this.bodySet,16,16,this.x-4, this.y-15,16,16);
                                    } else {
                                        ctx.drawImage(playerSheet, 16,16+this.bodySet,16,16,this.x-4, this.y-16,16,16);
                                        ctx.drawImage(playerSheet, 32,8+this.bodySet,16,8,this.x-4, this.y,16,8);
                                        for (var i=0; i<this.augments.length; i++) {     
                                            ctx.drawImage(playerSheet, 128+32,8+this.augments[i].drawCol,16,8,this.x-4, this.y,16,8);
                                            ctx.drawImage(playerSheet, 128+16,16+this.augments[i].drawCol,16,16,this.x-4, this.y-16,16,16);
                                        }
                                    }
                                }
                                
                            }
                        },
                init: 	function() {
							this.health = 10;
							this.maxHealth = 10;
							this.spirit = 10;
							this.maxSpirit = 10;
							this.curse = 0;
							this.moveWhileAttacking = false;
							
							this.x = 9*tileSize;
							this.y = 8*tileSize;
							this.dir = 2;
							this.strafe = false;
							this.moving = false;
							this.attacking = false;
							this.speed = 1;
							this.base_damage = 1;
							this.base_defense = 1;

							this.healthGen = 0;
							this.spiritGen = .1;
							this.curseGen = .0001;
							this.exp = 0;
							this.lvl = 0;
							
							this.augments = [];
							this.keys = [];
							
							this.anim_index = 0;
							this.animCounter = -1;
							
							this.wepIndex = 0;
						}, 
				keys:[],
				wepIndex: 0,
				weapons:[]
    };
    
	var wep_test = 	{   init_cost: 4,
                        cont: false,
                        swung: false,
                        use_cost: .1,
                        knockback: 8,
                        curseScale: 1.5,
                        aoe: [[{x: -12, y: -2, sprite: 33, dur:1, dirXadj: 8, dirYadj: 0},{x: -12, y: -10, sprite: 1, dur:1, dirXadj: 8, dirYadj: 8},{x: 0, y: -14, sprite: 2, dur:8, dirXadj: 0, dirYadj: 8}],
                              [{x: +2, y: +8, sprite: 66, dur:1, dirXadj: 0, dirYadj: 0},{x: -10, y: +8, sprite: 65, dur:1, dirXadj: 8, dirYadj: 0},{x: -12, y: -2, sprite: 33, dur:8, dirXadj: 8, dirYadj: 8}],
                              [{x: +12, y: -2, sprite: 35, dur:1, dirXadj: 0, dirYadj: 8},{x: +12, y: +8, sprite: 67, dur:1, dirXadj: 0, dirYadj: 0},{x: +2, y: +8, sprite: 66, dur:8, dirXadj: 8, dirYadj: 0}],
                              [{x: +2, y: -8, sprite: 2, dur:1, dirXadj: 8, dirYadj: 8},{x: +8, y: -8, sprite: 3, dur:1, dirXadj: 0, dirYadj: 8},{x: +12, y: -2, sprite: 35, dur:8, dirXadj: 0, dirYadj: 8}]
                             ],
                        damage: 1,
                        durCount:0,
                        atkIndex:0,
                        actioning: false,
                        update: function() {
                                    
                                    if (this.actioning == true) {
                                        this.durCount++;
                                        
                                        drawSprite(this.aoe[player.dir][this.atkIndex].sprite, player.x+this.aoe[player.dir][this.atkIndex].x, player.y+this.aoe[player.dir][this.atkIndex].y);
                                        for (var i=0; i<map[mapLoc.y][mapLoc.x].contents.length; i++) {
                                            if (map[mapLoc.y][mapLoc.x].contents[i].type == 'mob') {
                                                
                                                if (map[mapLoc.y][mapLoc.x].contents[i].alive == true &&
                                                    ((map[mapLoc.y][mapLoc.x].contents[i].loc.x+8 >= player.x+this.aoe[player.dir][this.atkIndex].x && 
                                                    map[mapLoc.y][mapLoc.x].contents[i].loc.x+8 < player.x+this.aoe[player.dir][this.atkIndex].x+tileSize) ||
                                                    (map[mapLoc.y][mapLoc.x].contents[i].loc.x >= player.x+this.aoe[player.dir][this.atkIndex].x && 
                                                    map[mapLoc.y][mapLoc.x].contents[i].loc.x < player.x+this.aoe[player.dir][this.atkIndex].x+tileSize)) &&
                                                    ((map[mapLoc.y][mapLoc.x].contents[i].loc.y+8 >= player.y+this.aoe[player.dir][this.atkIndex].y && 
                                                    map[mapLoc.y][mapLoc.x].contents[i].loc.y+8 < player.y+this.aoe[player.dir][this.atkIndex].y+tileSize) ||
                                                    (map[mapLoc.y][mapLoc.x].contents[i].loc.y >= player.y+this.aoe[player.dir][this.atkIndex].y && 
                                                    map[mapLoc.y][mapLoc.x].contents[i].loc.y < player.y+this.aoe[player.dir][this.atkIndex].y+tileSize))) {
                                                    
                                                    map[mapLoc.y][mapLoc.x].contents[i].health = map[mapLoc.y][mapLoc.x].contents[i].health-((player.base_damage+this.damage)+player.curse*this.curseScale);
                                                    ctx.fillStyle = 'red';
                                                    ctx.fillRect(map[mapLoc.y][mapLoc.x].contents[i].loc.x, map[mapLoc.y][mapLoc.x].contents[i].loc.y, tileSize, tileSize);
                                                    if (player.dir == 0 && currLvl[1][Math.floor((map[mapLoc.y][mapLoc.x].contents[i].loc.y+4-this.knockback)/tileSize)][Math.floor((map[mapLoc.y][mapLoc.x].contents[i].loc.x+4)/tileSize)] == 0) {
                                                        map[mapLoc.y][mapLoc.x].contents[i].loc.y = map[mapLoc.y][mapLoc.x].contents[i].loc.y-this.knockback;
                                                    }
                                                    if (player.dir == 1 && currLvl[1][Math.floor((map[mapLoc.y][mapLoc.x].contents[i].loc.y+4)/tileSize)][Math.floor((map[mapLoc.y][mapLoc.x].contents[i].loc.x+4-this.knockback)/tileSize)] == 0) {
                                                        map[mapLoc.y][mapLoc.x].contents[i].loc.x = map[mapLoc.y][mapLoc.x].contents[i].loc.x-this.knockback;
                                                    }
                                                    if (player.dir == 2 && currLvl[1][Math.floor((map[mapLoc.y][mapLoc.x].contents[i].loc.y+4+this.knockback)/tileSize)][Math.floor((map[mapLoc.y][mapLoc.x].contents[i].loc.x+4)/tileSize)] == 0) {
                                                        map[mapLoc.y][mapLoc.x].contents[i].loc.y = map[mapLoc.y][mapLoc.x].contents[i].loc.y+this.knockback;
                                                    }
                                                    if (player.dir == 3 && currLvl[1][Math.floor((map[mapLoc.y][mapLoc.x].contents[i].loc.y+4)/tileSize)][Math.floor((map[mapLoc.y][mapLoc.x].contents[i].loc.x+4+this.knockback)/tileSize)] == 0) {
                                                        map[mapLoc.y][mapLoc.x].contents[i].loc.x = map[mapLoc.y][mapLoc.x].contents[i].loc.x+this.knockback;
                                                    }
                                                }
                                            }
                                        }
                                        //player.attacking = false;
                                        
                                        if (this.durCount > this.aoe[player.dir][this.atkIndex].dur) {
                                            this.durCount = 0;
                                            this.atkIndex++;
                                            if (this.atkIndex >= this.aoe[player.dir].length) {
                                                this.atkIndex = 0;
                                                this.actioning = false;
                                                if (this.cont == false) {
                                                    player.attacking = false;
                                                }
                                            }
                                        }
                                    }
                                },
                        action:	function() {
                                    if (this.actioning == false) {
                                        this.actioning = true;
                                        this.swung = true;
                                        this.durCount = 0;
                                    }
								}
					};
					
	player.weapons.push(wep_test);
	
    {//augments
        var aug_scarf = 	{name: 'Scarf', effectText: '+.25 spd', drawCol: 0, onPickup: function(){player.speed = player.speed+.25;}, 			onDrop:	function(){player.speed = player.speed-.25;}, 				action:   function(){}};
        var aug_heartPin = 	{name: 'Pin',	effectText: '+.005 hpr', drawCol: 32, onPickup: function() {player.healthGen = player.healthGen+.005;}, 	onDrop:	function(){player.healthGen = player.healthGen-.005;}, 		action:    function(){}};
        var aug_bracelet = 	{name: 'Brace',	effectText: '+.1 spr', drawCol: 64, onPickup: function(){player.spiritGen = player.spiritGen+.1;}, 	onDrop:	function(){player.spiritGen = player.spiritGen-.1;}, 		action:    function(){}};
        var aug_tabard = 	{name: 'Tabard',effectText: '+move+atk', drawCol: 96, onPickup: function(){player.moveWhileAttacking = true;}, onDrop:	function(){player.moveWhileAttacking = false;},	action:    function(){}};
        var aug_robe = 		{name: 'Robe',	effectText: '+1 def', drawCol: 128, onPickup: function(){player.base_defense = player.base_defense+1}, onDrop:	function(){player.base_defense = player.base_defense-1}, action:    function(){}};
        var aug_horns = 	{name: 'Horns',	effectText: '+1 dmg', drawCol: 160, onPickup: function(){player.base_damage = player.base_damage+1}, 	onDrop:	function(){player.base_damage = player.base_damage-1}, 		action:    function(){}};
    }
    var augments = [aug_scarf,aug_heartPin,aug_bracelet,aug_tabard,aug_robe,aug_horns,aug_scarf];
    
    {//room items
        var con_mob = {type: 'mob', sprite: [705], loc: {x: -1, y:-1}, speed: 1, health: 10, alive: true, exp_reward: 1,
                        damage: 1,
                        cursePenalty: 1,
                        action:	function() {
                                    if (this.health <= 0 && this.alive == true) {
                                        player.exp = player.exp+this.exp_reward;
                                        player.curse = player.curse + this.cursePenalty;
                                        remMobs--;
                                        map[mapLoc.y][mapLoc.x].contents.push($.extend(true, {}, con_drop));
                                        map[mapLoc.y][mapLoc.x].contents[map[mapLoc.y][mapLoc.x].contents.length-1].loc.x = this.loc.x;
                                        map[mapLoc.y][mapLoc.x].contents[map[mapLoc.y][mapLoc.x].contents.length-1].loc.y = this.loc.y;
                                        this.alive = false;
                                    }
                                    if (this.alive == true) {
                                        
                                        var rand = Math.floor(Math.random()*8);
                                        
                                        if (rand == 0) {
                                            this.speed = 1.5;
                                            if ((this.loc.x - player.x) > 0) {
                                                rand = 1;
                                            } else {
                                                rand = 3;
                                            }
                                        } else if (rand == 1){
                                            this.speed = 1.5;
                                            if ((this.loc.y - player.y) > 0) {
                                                rand = 0;
                                            } else {
                                                rand = 2;
                                            }
                                        } else {
                                            this.speed  = 1;
                                            rand = Math.floor(Math.random()*4);
                                        }
                                        
                                        if (rand == 0) {
                                            if (this.loc.y >= 16 
                                                && currLvl[1][Math.floor((Math.floor(this.loc.y)-.5)/8)][Math.floor(Math.floor(this.loc.x)/8)] ==0
                                                && currLvl[1][Math.floor((Math.floor(this.loc.y)-.5)/8)][Math.ceil(Math.ceil(this.loc.x)/8)] ==0) {
                                                this.loc.y-=this.speed;
                                            }
                                        }
                                        if (rand == 1) {
                                            if (this.loc.x >= 16 
                                                && currLvl[1][Math.floor((Math.floor(this.loc.y))/8)][Math.floor((Math.floor(this.loc.x)-.5)/8)] == 0
                                                && currLvl[1][Math.ceil(((Math.ceil(this.loc.y)))/8)][Math.floor((Math.floor(this.loc.x)-.5)/8)] == 0) {
                                                this.loc.x-=this.speed;
                                            }
                                        }
                                        if (rand == 2) {
                                            if (this.loc.y+8 < screenHeight-32 
                                                && currLvl[1][Math.ceil((Math.ceil(this.loc.y)+.5)/8)][Math.floor(Math.floor(this.loc.x)/8)] == 0
                                                && currLvl[1][Math.ceil((Math.ceil(this.loc.y)+.5)/8)][Math.ceil(Math.ceil(this.loc.x)/8)] == 0) {
                                                this.loc.y+=this.speed;
                                            }
                                        }
                                        if (rand == 3) {
                                            if (this.loc.x+8 < screenWidth-16
                                                && currLvl[1][Math.ceil(Math.ceil(this.loc.y)/8)][Math.ceil((Math.ceil(this.loc.x)+.5)/8)] == 0
                                                && currLvl[1][Math.floor(Math.floor(this.loc.y)/8)][Math.ceil((Math.ceil(this.loc.x)+.5)/8)] == 0) {
                                                this.loc.x+=this.speed;
                                            }
                                        }
                                        
                                        if (player.invincible == false && player.x <= (this.loc.x)+8 &&  player.x > (this.loc.x)-8 && player.y <= (this.loc.y)+8 &&  player.y > (this.loc.y)-8) {
                                            player.health = player.health-(this.damage-player.base_defense/10);
                                            
                                            if (player.invincible == false && player.dir == 0 && currLvl[1][Math.floor((player.y+8)/tileSize)][Math.floor((player.x)/tileSize)] == 0) {
                                                player.y+=8;
                                            }
                                            if (player.invincible == false && player.dir == 1 && currLvl[1][Math.floor((player.y)/tileSize)][Math.floor((player.x+8)/tileSize)] == 0) {
                                                player.x+=8;
                                            }
                                            if (player.invincible == false && player.dir == 2 && currLvl[1][Math.floor((player.y-8)/tileSize)][Math.floor((player.x)/tileSize)] == 0) {
                                                player.y-=8;
                                            }
                                            if (player.invincible == false && player.dir == 3 && currLvl[1][Math.floor((player.y)/tileSize)][Math.floor((player.x-8)/tileSize)] == 0) {
                                                player.x-=8;
                                            }
                                            player.invincible = true;
                                            player.invincCounter = 0;
                                        }
                            }
                            
                        },
                        draw:	function() {
                                    if (this.alive == true) {
                                        drawSprite(this.sprite[0], this.loc.x, this.loc.y);
                                    }
                                }
        };
        var con_aug = {type: 'aug', sprite: [582,583], loc: {x: 9*tileSize, y: 8*tileSize}, collected: false,
                        action:	function() {
                            if (player.x <= (this.loc.x)+4 && player.x > (this.loc.x)-4 && 
                                player.y <= (this.loc.y)+4 && player.y > (this.loc.y)-4 &&
                                this.collected == false) {
                                player.augments.push(augments[this.aug]);
								if (player.augments.length > player.maxAugs) {
									player.augments[0].onDrop();
									player.augments.shift();
								}
                                augments[this.aug].onPickup();
                                this.collected = true;
                            }
                        },
                        draw:	function() {
                                    if (this.collected == false) {	
                                        if (blink == true) {
                                            drawSprite(this.sprite[0], this.loc.x, this.loc.y);
                                        } else {
                                            drawSprite(this.sprite[1], this.loc.x, this.loc.y);
                                        }
                                    }
                                },
                        aug: -1
        };
        var con_key = {type: 'key', sprite: [549], loc: {x: 9*tileSize, y: 8*tileSize}, collected: false,
                        action:	function() {
                                    if (player.x <= (this.loc.x)+4 && player.x > (this.loc.x)-4 && 
                                        player.y <= (this.loc.y)+4 && player.y > (this.loc.y)-4 &&
                                        this.collected == false) {
                                        player.keys.push(this);
                                        remKeys--;
                                        this.collected = true;
                                    }
                                },
                        draw:	function() {
                                    if (this.collected == false) {	
                                        drawSprite(this.sprite[0], this.loc.x, this.loc.y);
                                    }
                                }
        };
        var con_drop = {type: 'drop', sprite: [583], loc: {x:-1,y:-1}, collected: false,
                        action: function() {
                            if (player.x <= (this.loc.x)+4 && player.x > (this.loc.x)-4 && 
                                player.y <= (this.loc.y)+4 && player.y > (this.loc.y)-4 &&
                                this.collected == false) {
                                player.health = player.health+4;
                                this.collected = true;
                            }
                        },
                        draw: function() {
                            if (this.collected == false) {
                                drawSprite(this.sprite[0], this.loc.x, this.loc.y);
                            }
                        }
                
        };
        var con_goal = {type: 'goal', sprite: [581], loc: {x: 9.5*tileSize, y: 8*tileSize},
                        action:	function() {
                            if (player.x <= (this.loc.x)+4 && player.x > (this.loc.x)-4 && player.y <= (this.loc.y)+4 && player.y > (this.loc.y)-4 
                                && (player.keys.length >= this.diff || remMobs == 0)) {
                                lvlComplete = true;
								var rand = Math.floor(Math.random()*pals.length); 
								palSwap(pals[rand]);
								
                                player.curse = player.curse*(.25);
                                console.log(lvlComplete);
                                rTransition = 4;
                                roomDrawY = 0-(2*screenHeight+16);
                                console.log('loading');
                                player.keys = [];
                                //difficulty++;
                                buildLevel(difficulty);
                            }
                        },
                        draw:	function() {
                                    drawSprite(this.sprite[0], this.loc.x, this.loc.y);
                                },
                        diff: -1
        };
    }
	var mobs = [con_mob];
    
    {//base rooms
        
        var base_0;
        var base_1;
        var base_2;
        var base_3;
        var base_4;
        var base_5;
        var base_6;
        var base_7;
        var base_8;
        var base_9;
        var base_10;
        var base_11;
        var base_12;
        var base_13;
        var base_14;
        
        var open_0;
        var open_1;
        var open_2;
        var open_3;
        var open_4;
        var open_5;
        var open_6;
        var open_7;
        var open_8;
        var open_9;
        var open_10;
        var open_11;
        var open_12;
        var open_13;
        var open_14;
        var open_15;
        var open_16;
        var open_17;
        var open_18;
        var open_19;
        var open_20;
        var open_21;
        var open_22;
        var open_23;
        var open_24;
        var open_25;
        var open_26;
        var open_27;
        var open_28;
        var open_29;
        var open_30;
        var open_31;
        var open_32;
        var open_33;
        var open_34;
        var open_35;
        var open_36;
        var open_37;
        var open_38;
        var open_39;
        var open_40;
        var open_41;
        var open_42;
        var open_43;
        var open_44;
        var open_45;
        var open_46;
        var open_47;
        var open_48;
        var open_49;
        var open_50;
        var open_51;
        var open_52;
        var open_53;
        var open_54;
        var open_55;
        var open_56;
        var open_57;
        var open_58;
        var open_59;
        var open_60;
        var open_61;
        var open_62;
        var open_63;
        var open_64;
    }
    var empty = {type:'empty',          config:[[9,10],[7,8],[9,10],[7,8]], contents:[], obs:[], discovered: false};
    
	var rooms = [];
	
    //input
	document.addEventListener('keydown', function(event) {
	  switch (event.keyCode) {
        case	74:	if (pressedKeys.indexOf('J')<0) {
						pressedKeys.push('J');
                        if (palette == true) {
                            palette = false;
                        } else {
                            palette = true;
                        }
					}
					break;
        case    65: if (pressedKeys.indexOf('A')<0) {
                        pressedKeys.push('A');
                    }
                    break;
        case    87: if (pressedKeys.indexOf('W')<0) {
                        pressedKeys.push('W');
                    }
                    break;
        case    68: if (pressedKeys.indexOf('D')<0) {
                        pressedKeys.push('D');
                    }
                    break;
        case    83: if (pressedKeys.indexOf('S')<0) {
                        pressedKeys.push('S');
                    }
                    break;
        case    77: if (pressedKeys.indexOf('M')<0) {
                        pressedKeys.push('M');
                        if (paused == true) {
                            menu = false;
                            bgm.play();
                        } else {
                            paused = true;
                            bgm.pause();
                            menu = true;
                            menuHeight = screenHeight-16;
                        }
                    }
                    break;
		case	32:	if (pressedKeys.indexOf('_')<0) {
                        if (player.spriit >= player.weapons[player.wepIndex].init_cost) {
                            player.attacking = true;
                            player.spirit = player.spirit-player.weapons[player.wepIndex].init_cost;
                        }
                        
						pressedKeys.push('_');
					}
					break;
      }
	}, false);
    
    document.addEventListener('keyup', function(event) {
	  switch (event.keyCode) {
        case	74:	pressedKeys.splice(pressedKeys.indexOf('J'),1);
                    break;
        case    65: pressedKeys.splice(pressedKeys.indexOf('A'),1);
                    break;
        case    87: pressedKeys.splice(pressedKeys.indexOf('W'),1);
                    break;
        case    68: pressedKeys.splice(pressedKeys.indexOf('D'),1);
                    break;
        case    83: pressedKeys.splice(pressedKeys.indexOf('S'),1);
                    break;
        case    77: pressedKeys.splice(pressedKeys.indexOf('M'),1);
                    break;
		case	32:	pressedKeys.splice(pressedKeys.indexOf('_'),1);
                    //player.attacking = false;
                    break;			
      }
	}, false);
    
	
    
	//-----------------------------------------------------------------------------
	//-
	//-								  START
	//-
	//-----------------------------------------------------------------------------
    
    roomTemplates.onload = function(){
        lctx.drawImage(roomTemplates,0,0);
        init();
        //start event loop
        //setInterval(mainLoop, Math.floor(1000/60));
        mainLoop();
    }
    
    //fps counter
    setInterval(function() {
        fps = frames;
        frames = 0;
    },1000);
    
    setInterval(function() {
        if (blink == true) {
            blink = false;
        } else {
            blink = true;
        }
    },250);
    
    //read in room data from image
	function parseRoomData(x,y, mini) {
		var rawData = lctx.getImageData(x,y,20,16).data;
		var roomMap = [[],[],[]];
		var doorData = [[],[],[],[]];
		var row = [];
        var randBot = [159,157,93];
        var randMid = [127,125,61];
		for (var i=0; i< 16; i++) {
			row = [];
			for (var j=0; j<(20*4); j += 4) {
                if (rawData[i*(20*4)+j] == 60 && rawData[i*(20*4)+j+1] == 188 && rawData[i*(20*4)+j+2] == 252) {
                    row.push(30);
                }
                if (rawData[i*(20*4)+j] == 0 && rawData[i*(20*4)+j+1] == 120 && rawData[i*(20*4)+j+2] == 248) {
                    row.push(31);
                }
                if (rawData[i*(20*4)+j] == 0 && rawData[i*(20*4)+j+1] == 0 && rawData[i*(20*4)+j+2] == 252) {
                    row.push(32)
                }
                if (rawData[i*(20*4)+j] == 104 && rawData[i*(20*4)+j+1] == 136 && rawData[i*(20*4)+j+2] == 252) {
                    row.push(62);
                }
                if (rawData[i*(20*4)+j] == 0 && rawData[i*(20*4)+j+1] == 88 && rawData[i*(20*4)+j+2] == 248) {
                    row.push(63);
                }
                if (rawData[i*(20*4)+j] == 0 && rawData[i*(20*4)+j+1] == 0 && rawData[i*(20*4)+j+2] == 188) {
                    row.push(64);
                }
                if (rawData[i*(20*4)+j] == 152 && rawData[i*(20*4)+j+1] == 120 && rawData[i*(20*4)+j+2] == 248) {
                    row.push(94);
                }
                if (rawData[i*(20*4)+j] == 104 && rawData[i*(20*4)+j+1] == 68 && rawData[i*(20*4)+j+2] == 252) {
                    row.push(95);
                }
                if (rawData[i*(20*4)+j] == 68 && rawData[i*(20*4)+j+1] == 40 && rawData[i*(20*4)+j+2] == 188) {
                    row.push(96);
                }
                if (rawData[i*(20*4)+j] == 248 && rawData[i*(20*4)+j+1] == 120 && rawData[i*(20*4)+j+2] == 248) {
                    row.push(126);
                }
                if (rawData[i*(20*4)+j] == 216 && rawData[i*(20*4)+j+1] == 0 && rawData[i*(20*4)+j+2] == 204) {
                    //pick random
                    var rand = Math.floor(Math.random()*randBot.length);
                    row.push(randMid[rand]);
                }
                if (rawData[i*(20*4)+j] == 148 && rawData[i*(20*4)+j+1] == 0 && rawData[i*(20*4)+j+2] == 132) {
                    row.push(128);
                }
                if (rawData[i*(20*4)+j] == 248 && rawData[i*(20*4)+j+1] == 88 && rawData[i*(20*4)+j+2] == 152) {
                    row.push(158);
                }
                if (rawData[i*(20*4)+j] == 228 && rawData[i*(20*4)+j+1] == 0 && rawData[i*(20*4)+j+2] == 88) {
                    //pick random
                    var rand = Math.floor(Math.random()*randMid.length);
                    row.push(randBot[rand]);
                }
                if (rawData[i*(20*4)+j] == 168 && rawData[i*(20*4)+j+1] == 0 && rawData[i*(20*4)+j+2] == 32) {
                    row.push(160);
                }
                if (rawData[i*(20*4)+j] == 0 && rawData[i*(20*4)+j+1] == 0 && rawData[i*(20*4)+j+2] == 0) {
                    row.push(0);
                    //mark for door
                    if (i == 0) {
                        doorData[0].push(parseInt(j/4));
                    }
                    if (i== 15) {
                        doorData[2].push(parseInt(j/4));
                    }
                    if (j==0) {
                        doorData[1].push(i);
                    }
                    if (j == (20*4)-4) {
                        doorData[3].push(i)
                    }
                    
                }
                if (rawData[i*(20*4)+j] == 255 && rawData[i*(20*4)+j+1] == 255 && rawData[i*(20*4)+j+2] == 255) {
                    row.push(0);
                }
			}
			roomMap[1].push(row);
		}
        for (var i=0; i<16; i++) {
            row = [];
            for (var j=0; j<20; j++) {
                row.push(0);
            }
            roomMap[2].push(row);
        }
        return{type:'room', mini: mini, map:roomMap, config:doorData, contents:[], obs:-1, discovered:false, wallStyle:0, floorStyle:0};
	}
	
    //buld room templates
    function initRooms() {
        
        //read in room data
        base_0 = parseRoomData(0,16,925);
        base_1 = parseRoomData(20,16,926);
        base_2 = parseRoomData(40,16,927);
        base_3 = parseRoomData(60,16,928);
        base_4 = parseRoomData(0,32,957);
        base_5 = parseRoomData(20,32,958);
        base_6 = parseRoomData(40,32,959);
        base_7 = parseRoomData(60,32,960);
        base_8 = parseRoomData(0,48,989);
        base_9 = parseRoomData(20,48,990);
        base_10 = parseRoomData(40,48,991);
        base_11 = parseRoomData(60,48,992);
        base_12 = parseRoomData(0,64,1021);
        base_13 = parseRoomData(20,64,1022);
        base_14 = parseRoomData(40,64,1023);
        
        open_0 = parseRoomData(0,80,764);
        
        open_1 = parseRoomData(0,96,789);
        open_2 = parseRoomData(20,96,790);
        open_3 = parseRoomData(40,96,791);
        open_4 = parseRoomData(60,96,792);
        open_5 = parseRoomData(80,96,793);
        open_6 = parseRoomData(100,96,794);
        open_7 = parseRoomData(120,96,795);
        open_8 = parseRoomData(140,96,796);
        
        open_9 = parseRoomData(0,112,821);
        open_10 = parseRoomData(20,112,822);
        open_11 = parseRoomData(40,112,823);
        open_12 = parseRoomData(60,112,824);
        open_13 = parseRoomData(80,112,825);
        open_14 = parseRoomData(100,112,826);
        open_15 = parseRoomData(120,112,827);
        open_16 = parseRoomData(140,112,828);
        
        open_17 = parseRoomData(0,128,853);
        open_18 = parseRoomData(20,128,854);
        open_19 = parseRoomData(40,128,855);
        open_20 = parseRoomData(60,128,856);
        open_21 = parseRoomData(80,128,857);
        open_22 = parseRoomData(100,128,858);
        open_23 = parseRoomData(120,128,859);
        open_24 = parseRoomData(140,128,860);
        
        open_25 = parseRoomData(0,144,885);
        open_26 = parseRoomData(20,144,886);
        open_27 = parseRoomData(40,144,887);
        open_28 = parseRoomData(60,144,888);
        open_29 = parseRoomData(80,144,889);
        open_30 = parseRoomData(100,144,890);
        open_31 = parseRoomData(120,144,891);
        open_32 = parseRoomData(140,144,892);
        
        open_33 = parseRoomData(0,160,917);
        open_34 = parseRoomData(20,160,918);
        open_35 = parseRoomData(40,160,919);
        open_36 = parseRoomData(60,160,920);
        open_37 = parseRoomData(80,160,921);
        open_38 = parseRoomData(100,160,922);
        open_39 = parseRoomData(120,160,923);
        open_40 = parseRoomData(140,160,924);
        
        open_41 = parseRoomData(0,176,949);
        open_42 = parseRoomData(20,176,950);
        open_43 = parseRoomData(40,176,951);
        open_44 = parseRoomData(60,176,952);
        open_45 = parseRoomData(80,176,953);
        open_46 = parseRoomData(100,176,954);
        open_47 = parseRoomData(120,176,955);
        open_48 = parseRoomData(140,176,956);
        
        open_49 = parseRoomData(0,192,981);
        open_50 = parseRoomData(20,192,982);
        open_51 = parseRoomData(40,192,983);
        open_52 = parseRoomData(60,192,984);
        open_53 = parseRoomData(80,192,985);
        open_54 = parseRoomData(100,192,986);
        open_55 = parseRoomData(120,192,987);
        open_56 = parseRoomData(140,192,988);
        
        open_57 = parseRoomData(0,208,1013);
        open_58 = parseRoomData(20,208,1014);
        open_59 = parseRoomData(40,208,1015);
        open_60 = parseRoomData(60,208,1016);
        open_61 = parseRoomData(80,208,1017);
        open_62 = parseRoomData(100,208,1018);
        open_63 = parseRoomData(120,208,1019);
        open_64 = parseRoomData(140,208,1020);
        
        rooms = [base_0,base_1,base_2,base_3,base_4,base_5,base_6,base_7,base_8,base_9,base_10,base_11,base_12,base_13,base_14
                ,open_0,open_1,open_2,open_3,open_4,open_5,open_6,open_7,open_8,open_9,open_10,open_11,open_12,open_13,open_14,open_15
                ,open_16,open_17,open_18,open_19,open_20,open_21,open_22,open_23,open_24,open_25,open_26,open_27,open_28,open_29,open_30,open_31
                ,open_32,open_33,open_34,open_35,open_36,open_37,open_38,open_39,open_40,open_41,open_42,open_43,open_44,open_45,open_46,open_47
                ,open_48,open_49,open_50,open_51,open_52,open_53,open_54,open_55,open_56,open_57,open_58,open_59,open_60,open_61,open_62,open_63
                ,open_64];
    }
    
    //kick off EVERYTHING
    function init() {
        bgm.loop = true;
        bgm.play();
        initRooms();
        
		player.init();
        depth = -1;
        difficulty = 1;

        buildLevel(difficulty);
        prevLvl = JSON.parse(JSON.stringify(currLvl));

        //init palette
        var rand = Math.floor(Math.random()*pals.length);
        palSwap(pals[rand]);
        rand = Math.floor(Math.random()*sets.length);
        wallSet = sets[rand];
    }
    
    function palSwap(newPal) {
        currPal = newPal;
    }
    
    //build room config from .tmx file
    function buildConfig(config_name) {
        config_name = 'assets/'+config_name+'.tmx';
        console.log(config_name);
        var tiledXML;
		var tiled;
		var background,collision,overlap;
		var newmap = [];
		var rawFile = new XMLHttpRequest();
		rawFile.open('GET', config_name, false);
		rawFile.onreadystatechange = function () {
			if (rawFile.readyState === 4) {
				if (rawFile.status === 200 || rawFile.status === 0) {
					tiledXML = rawFile.responseText;
                    console.log(rawFile.responseText);
                    console.log(rawFile.status);
				}
			}
		}
		rawFile.send(null);

		tiledXML = $.parseXML(tiledXML);
		$tiled = $(tiledXML);
		$tiled = $tiled.find('data');
        
        background = $tiled[0].innerHTML;
		collision = $tiled[1].innerHTML;
		overlap = $tiled[2].innerHTML;
		
		background = background.split('\n');
		background.shift();
		background.pop();
		for (var i=0; i<background.length; i++) {
			background[i] = background[i].split(',');
			if (i!=background.length-1) {
				background[i].pop();
			}
			
		}
		for (var i=0; i<background.length; i++) {
			for (var j=0; j<background[i].length; j++) {
				background[i][j] = parseInt(background[i][j]);
			}
		}
		newmap.push(background);
		
		collision = collision.split('\n');
		collision.shift();
		collision.pop();
		for (var i=0; i<collision.length; i++) {
			collision[i] = collision[i].split(',');
			if (i!=collision.length-1) {
				collision[i].pop();
			}
		}
		for (var i=0; i<collision.length; i++) {
			for (var j=0; j<collision[i].length; j++) {
				collision[i][j] = parseInt(collision[i][j]);
			}
		}
		newmap.push(collision);
		overlap = overlap.split('\n');
		overlap.shift();
		overlap.pop();
		for (var i=0; i<overlap.length; i++) {
			overlap[i] = overlap[i].split(',');
			if (i!=overlap.length-1) {
				overlap[i].pop();
			}
		}
		for (var i=0; i<overlap.length; i++) {
			for (var j=0; j<overlap[i].length; j++) {
				overlap[i][j] = parseInt(overlap[i][j]);
			}
		}
		newmap.push(overlap);
		return newmap;
    }
    
    //generate a level
	function buildLevel(size, gen, prev) {
        depth++;
        remKeys = 0;
        remMobs = 0;
        if (prev) {
            map = prev;
        } else {
            map = [ [0,0,0],
                    [0,empty,0],
                    [0,0,0]];
        }
		
		mapLoc = {x:1, y:1};
        cards = [];
        var emptList = [];
        var rand;
        var i,j,k
        var seed = '';
        var genIndex = 0;
        var config;
        var minRooms = 3+size;
        var numRooms = 0;
        var floorPal = [190];
        var posFloors = [191,192,222,223,224,254,255,256];
        var walls = 0;
        var floorStyle = 0;
        if (gen) {
            size = parseInt(gen.substring(0,gen.indexOf('e')));
            genIndex = gen.indexOf('e')+1;
        }
        seed+=size+'_';
        
        //190,191,192,222,223,224,254,255,256
        //make a floor palette
        if (gen) {
            rand = parseInt(gen.charAt(genIndex));
            genIndex++;
        } else {
            rand = Math.floor(Math.random()*2);
        }
        seed+=rand+'_';
        
        floorStyle = rand*3;
        
        for (i=0; i<2; i++) {
            if (gen) {
                rand = parseInt(gen.charAt(genIndex));
                genIndex++;
            } else {
                rand = Math.floor(Math.random()*posFloors.length);
            }
            seed+=rand+'_';
            floorPal.push(posFloors[rand]);
            posFloors.splice(rand, 1);
        }
        if (gen) {
            rand = parseInt(gen.charAt(genIndex));
            genIndex++;
        } else {
            rand = Math.floor(Math.random()*3);
        }
        seed+=rand+'_';
        if (rand == 0) {
            floorPal.push(286);
        }
        if (rand == 1) {
            floorPal.push(287);
        }
        if (rand == 2) {
            floorPal.push(288);
        }
        //shuffle(floorPal);
        
        if (gen) {
            rand = parseInt(gen.charAt(genIndex));
            genIndex++;
        } else {
            rand = Math.floor(Math.random()*3);
        }
        seed+=rand+'_';
        
        walls = rand*4;
        
        function expandMap(y, x) {
            //expand map if needed
            if (y == 0) {
                var newRow = [];
                for (c=0; c<map[0].length; c++) {
                    newRow.push(0);
                }
                map.unshift(newRow);
                mapLoc.y++;
                for (c=0; c<emptList.length; c++) {
                    emptList[c].y++;
                }
            }
            if (x == 0) {
                for (c=0; c<map.length; c++) {
                    map[c].unshift(0);
                }
                mapLoc.x++;
                for (c=0; c<emptList.length; c++) {
                    emptList[c].x++;
                }
            }
            if (y == map.length-1) {
                var newRow = [];
                for (c=0; c<map[0].length; c++) {
                    newRow.push(0);
                }
                map.push(newRow);
            }
            if (x == map[emptList[j].y].length-1) {
                for (c=0; c<map.length; c++) {
                    map[c].push(0);
                }
            }
        } 
        
        function genFloor(y, x) {
            var floorRow = [];
            var floorRand;
            for (var k=0; k<16; k++) {
                floorRow = [];
                for (var l=0; l<20; l++) {
                    if (gen) {
                        floorRand = parseInt(gen.charAt(genIndex));
                        genIndex++;
                    } else {
                        floorRand = Math.floor(Math.random()*8);
                    }
                    seed+=floorRand+'_'; 
                    
                    if (floorRand == 0) {
                        floorRow.push(floorPal[3]);
                    }
                    if (floorRand == 1 || floorRand == 2) {
                        floorRow.push(floorPal[1]);
                    }
                    if (floorRand == 3 || floorRand == 4) {
                        floorRow.push(floorPal[2]);
                    }
                    if (floorRand > 4) {
                        floorRow.push(floorPal[0]);
                    }
                }
                map[y][x].map[0].push(JSON.parse(JSON.stringify(floorRow)));
            }
        }
        
        for (i=0; i<size; i++) {
            //build list of expandable rooms
            for (j=0; j<map.length; j++) {
                for (k=0; k<map[j].length; k++) {
                    if (map[j][k].type == 'empty' ||
                        JSON.stringify(map[j][k].config) == JSON.stringify(base_1.config) ||
                        JSON.stringify(map[j][k].config) == JSON.stringify(base_2.config) ||
                        JSON.stringify(map[j][k].config) == JSON.stringify(base_3.config) ||
                        JSON.stringify(map[j][k].config) == JSON.stringify(base_4.config) ||
                        JSON.stringify(map[j][k].config) == JSON.stringify(open_40.config) ||
                        JSON.stringify(map[j][k].config) == JSON.stringify(open_48.config) ||
                        JSON.stringify(map[j][k].config) == JSON.stringify(open_56.config) ||
                        JSON.stringify(map[j][k].config) == JSON.stringify(open_64.config)) {
                        emptList.push({x:k, y:j});
                    }
                }
            }
			
            //expand every empty room in list
            for (j=0; j<emptList.length; j++) {
                //check configs of surrounding rooms;
                var matchConfig = [];
                
                if (map[emptList[j].y-1][emptList[j].x] == 0) {   //above
                    matchConfig.push(2);
                } else {
                    matchConfig.push(map[emptList[j].y-1][emptList[j].x].config[2]);
                }
                if (map[emptList[j].y][emptList[j].x-1] == 0) {   //left
                    matchConfig.push(2);
                } else {
                    matchConfig.push(map[emptList[j].y][emptList[j].x-1].config[3]);
                }
                if (map[emptList[j].y+1][emptList[j].x] == 0) {   //below
                    matchConfig.push(2);
                } else {
                    matchConfig.push(map[emptList[j].y+1][emptList[j].x].config[0]);
                }
                if (map[emptList[j].y][emptList[j].x+1] == 0) {   //right
                    matchConfig.push(2);
                } else {
                    matchConfig.push(map[emptList[j].y][emptList[j].x+1].config[1]);
                }

                //build list of applicable rooms
                var appList = [];
                for (k=0; k<rooms.length; k++) {
					if ((JSON.stringify(rooms[k].config[0]) == JSON.stringify(matchConfig[0]) || matchConfig[0] == 2) &&
						(JSON.stringify(rooms[k].config[1]) == JSON.stringify(matchConfig[1]) || matchConfig[1] == 2) &&
						(JSON.stringify(rooms[k].config[2]) == JSON.stringify(matchConfig[2]) || matchConfig[2] == 2) &&
						(JSON.stringify(rooms[k].config[3]) == JSON.stringify(matchConfig[3]) || matchConfig[3] == 2)) {
                        appList.push(JSON.parse(JSON.stringify(rooms[k])));
                    }
                }
                
                //pick a room
                if (gen) {
                    rand = parseInt(gen.charAt(genIndex));
                    genIndex++;
                } else {
                    rand = Math.floor(Math.random()*appList.length);
                }
                seed+=rand+'_';
                map[emptList[j].y][emptList[j].x] = JSON.parse(JSON.stringify(appList[rand]));
                numRooms++;
                
                //make a floor for the new room here
                
                genFloor(emptList[j].y, emptList[j].x);
                
                map[emptList[j].y][emptList[j].x].wallStyle = walls;
                map[emptList[j].y][emptList[j].x].floorStyle = floorStyle;
                
                //create new empty's
                if (appList[rand].config[0].length > 0 && map[emptList[j].y-1][emptList[j].x] == 0) {
                    map[emptList[j].y-1][emptList[j].x] = JSON.parse(JSON.stringify(empty));
                    expandMap(emptList[j].y-1, emptList[j].x);
                }
                if (appList[rand].config[1].length > 0 && map[emptList[j].y][emptList[j].x-1] == 0) {
                    map[emptList[j].y][emptList[j].x-1] = JSON.parse(JSON.stringify(empty));
                    expandMap(emptList[j].y, emptList[j].x-1);
                }
                if (appList[rand].config[2].length > 0 && map[emptList[j].y+1][emptList[j].x] == 0) {
                    map[emptList[j].y+1][emptList[j].x] = JSON.parse(JSON.stringify(empty));
                    expandMap(emptList[j].y+1, emptList[j].x);
                }
                if (appList[rand].config[3].length > 0 && map[emptList[j].y][emptList[j].x+1] == 0) {
                    map[emptList[j].y][emptList[j].x+1] = JSON.parse(JSON.stringify(empty));
                    expandMap(emptList[j].y, emptList[j].x+1);
                }
              
            }
            emptList = [];
            if (numRooms < minRooms) {
                i--;
            }
        }
        //cap off the remaining empties
        //build list of remaining empties
        for (j=0; j<map.length; j++) {
            for (k=0; k<map[j].length; k++) {
                if (map[j][k].type == 'empty') {
                    emptList.push({x:k, y:j});
                }
            }
        }
        
        for (j=0; j<emptList.length; j++) {
            if (map[emptList[j].y][emptList[j].x].type == 'empty') {
                var capConfig = [];
        
                if (map[emptList[j].y-1][emptList[j].x] == 0) {   //above
                    capConfig.push([]);
                } else {
                    capConfig.push(map[emptList[j].y-1][emptList[j].x].config[2]);
                }
                if (map[emptList[j].y][emptList[j].x-1] == 0) {   //left
                    capConfig.push([]);
                } else {
                    capConfig.push(map[emptList[j].y][emptList[j].x-1].config[3]);
                }
                if (map[emptList[j].y+1][emptList[j].x] == 0) {   //below
                    capConfig.push([]);
                } else {
                    capConfig.push(map[emptList[j].y+1][emptList[j].x].config[0]);
                }
                if (map[emptList[j].y][emptList[j].x+1] == 0) {   //right
                    capConfig.push([]);
                } else {
                    capConfig.push(map[emptList[j].y][emptList[j].x+1].config[1]);
                }
                
                //build list of applicable rooms
                var capList = [];
                for (k=0; k<rooms.length; k++) {
					if ((JSON.stringify(rooms[k].config[0]) == JSON.stringify(capConfig[0])) &&
						(JSON.stringify(rooms[k].config[1]) == JSON.stringify(capConfig[1])) &&
						(JSON.stringify(rooms[k].config[2]) == JSON.stringify(capConfig[2])) &&
						(JSON.stringify(rooms[k].config[3]) == JSON.stringify(capConfig[3]))) {
                        capList.push(JSON.parse(JSON.stringify(rooms[k])));
                    }
                }
                //pick a room
                if (gen) {
                    rand = parseInt(gen.charAt(genIndex));
                    genIndex++;
                } else {
                    rand = Math.floor(Math.random()*capList.length);
                }
                seed+=rand+'_';
                map[emptList[j].y][emptList[j].x] = JSON.parse(JSON.stringify(capList[rand]));
                numRooms++;
                
                genFloor(emptList[j].y, emptList[j].x);
            
                map[emptList[j].y][emptList[j].x].wallStyle = walls;
                map[emptList[j].y][emptList[j].x].floorStyle = floorStyle;
            }
        }
        
        var connectables = 0;
        //check for connectibles
        for (i=0; i<map.length; i++) {
			for (j=0; j<map[i].length; j++) {
                if (map[i][j] !=0) {
                    // am I an open room?
                    if (map[i][j].config[0].length > 2 || map[i][j].config[1].length > 2 || map[i][j].config[2].length > 2 || map[i][j].config[3].length > 2) {
                        
                        //Do I neighbor another open room through a small door?
                        if (map[i][j].config[0].length <=2) {
                            connectables++;
                            if (map[i-1][j] !=0 &&
                                (map[i-1][j].config[0].length > 2 || map[i-1][j].config[1].length > 2 ||
                                map[i-1][j].config[2].length > 2 || map[i-1][j].config[3].length > 2)) {
                                
                                console.log('Bridging: '+i+','+j+' w '+(i-1)+','+(j));
                                //change rooms to connect openly
                                var nConfig = [JSON.parse(JSON.stringify(map[i-1][j].config[0])),JSON.parse(JSON.stringify(map[i-1][j].config[1])),
                                                [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18],JSON.parse(JSON.stringify(map[i-1][j].config[3]))];
                                var mConfig = [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18],JSON.parse(JSON.stringify(map[i][j].config[1])),
                                                JSON.parse(JSON.stringify(map[i][j].config[2])),JSON.parse(JSON.stringify(map[i][j].config[3]))];
                                                
                                for (k=0; k<rooms.length; k++) {
                                    if ((JSON.stringify(rooms[k].config[0]) == JSON.stringify(nConfig[0])) &&
                                        (JSON.stringify(rooms[k].config[1]) == JSON.stringify(nConfig[1])) &&
                                        (JSON.stringify(rooms[k].config[2]) == JSON.stringify(nConfig[2])) &&
                                        (JSON.stringify(rooms[k].config[3]) == JSON.stringify(nConfig[3]))) {
                                        map[i-1][j] = JSON.parse(JSON.stringify(rooms[k]));
                                        genFloor(i-1, j);
                                        map[i-1][j].wallStyle = walls;
                                        map[i-1][j].floorStyle = floorStyle;
                                    } 
                                    if ((JSON.stringify(rooms[k].config[0]) == JSON.stringify(mConfig[0])) &&
                                        (JSON.stringify(rooms[k].config[1]) == JSON.stringify(mConfig[1])) &&
                                        (JSON.stringify(rooms[k].config[2]) == JSON.stringify(mConfig[2])) &&
                                        (JSON.stringify(rooms[k].config[3]) == JSON.stringify(mConfig[3]))) {
                                        map[i][j] = JSON.parse(JSON.stringify(rooms[k]));
                                        genFloor(i, j);
                                        map[i][j].wallStyle = walls;
                                        map[i][j].floorStyle = floorStyle;
                                    }
                                }
                                
                                
                            }
                        }
                        if (map[i][j].config[1].length <=2) {
                            connectables++;
                            if (map[i][j-1] !=0 && 
                                (map[i][j-1].config[0].length > 2 || map[i][j-1].config[1].length > 2 ||
                                map[i][j-1].config[2].length > 2 || map[i][j-1].config[3].length > 2)) {
                                
                                console.log('Bridging: '+i+','+j+' w '+(i)+','+(j-1));
                                //change rooms to connect openly
                                var nConfig = [JSON.parse(JSON.stringify(map[i][j-1].config[0])),JSON.parse(JSON.stringify(map[i][j-1].config[1])),
                                                JSON.parse(JSON.stringify(map[i][j-1].config[2])),[1,2,3,4,5,6,7,8,9,10,11,12,13,14]];
                                var mConfig = [JSON.parse(JSON.stringify(map[i][j].config[0])),[1,2,3,4,5,6,7,8,9,10,11,12,13,14],
                                                JSON.parse(JSON.stringify(map[i][j].config[2])),JSON.parse(JSON.stringify(map[i][j].config[3]))];
                                
                                for (k=0; k<rooms.length; k++) {
                                    if ((JSON.stringify(rooms[k].config[0]) == JSON.stringify(nConfig[0])) &&
                                        (JSON.stringify(rooms[k].config[1]) == JSON.stringify(nConfig[1])) &&
                                        (JSON.stringify(rooms[k].config[2]) == JSON.stringify(nConfig[2])) &&
                                        (JSON.stringify(rooms[k].config[3]) == JSON.stringify(nConfig[3]))) {
                                        map[i][j-1] = JSON.parse(JSON.stringify(rooms[k]));
                                        genFloor(i, j-1);
                                        map[i][j-1].wallStyle = walls;
                                        map[i][j-1].floorStyle = floorStyle;
                                    } 
                                    if ((JSON.stringify(rooms[k].config[0]) == JSON.stringify(mConfig[0])) &&
                                        (JSON.stringify(rooms[k].config[1]) == JSON.stringify(mConfig[1])) &&
                                        (JSON.stringify(rooms[k].config[2]) == JSON.stringify(mConfig[2])) &&
                                        (JSON.stringify(rooms[k].config[3]) == JSON.stringify(mConfig[3]))) {
                                        map[i][j] = JSON.parse(JSON.stringify(rooms[k]));
                                        genFloor(i, j);
                                        map[i][j].wallStyle = walls;
                                        map[i][j].floorStyle = floorStyle;
                                    }
                                }
                            }
                        }
                    }
                } 
            }
        }
        console.log(connectables);
        
        //put goal in map
        var rList = [];
        for (i=0; i<map.length; i++) {
            for (j=0; j<map[i].length; j++) {
                if (map[i][j]!=0 && !(i == mapLoc.y && j == mapLoc.x)) {
                    rList.push({x: j, y: i});
                }
            }
        }
        console.log(map[mapLoc.y][mapLoc.x]);
        map[mapLoc.y][mapLoc.x].contents.push($.extend({}, con_goal));
        map[mapLoc.y][mapLoc.x].obs = buildConfig('config_goal');
		map[mapLoc.y][mapLoc.x].contents[0].diff = Math.ceil((rList.length-1)/2);
		goalTile.x = parseInt(mapLoc.x);
		goalTile.y = parseInt(mapLoc.y);
		var numKeys = Math.ceil((rList.length-1)/2);
		rList.splice(rand, 1);
        
		//put in keys
        remKeys = numKeys;
		for (i=0; i<numKeys; i++) {
			if (gen) {
				rand = gen.charAt(genIndex);
				genIndex++;
			} else {
				rand = Math.floor(Math.random()*rList.length);
			}
			seed+=rand+'_';
			map[rList[rand].y][rList[rand].x].contents.push($.extend(true, {}, con_key));
			rList.splice(rand,1);
			
		}
		//put mobs in rooms
		for (i=0; i<map.length; i++) {
			for (j=0; j<map[i].length; j++) {
				if (map[i][j] != 0 && !(i == mapLoc.y && j == mapLoc.x)) {
					if (gen) {
						rand = gen.charAt(genIndex);
						genIndex++;
					} else {
						rand = Math.floor(Math.random()*2);
					}
					seed+=rand+'_';
					if (rand == 0) {
						if (gen) {
							rand = gen.charAt(genIndex);
							genIndex++;
						} else {
							rand = Math.floor(Math.random()*mobs.length);
						}
						seed+=rand+'_';
						map[i][j].contents.push($.extend(true, {}, mobs[rand]));
                        remMobs++;
					}
				}
			}
		}
        //put powerups in rooms
        for (i=0; i<map.length; i++) {
            for (j=0; j<map[i].length; j++) {
                if (map[i][j] != 0 && !(i == mapLoc.y && j == mapLoc.x)) {
                    if (map[i][j].contents.length < 1) {
                        if (gen) {
                            rand = gen.charAt(genIndex);
                            genIndex++;
                        } else {
                            rand = Math.floor(Math.random()*2);
                        }
                        seed+=rand+'_';
                        if (rand == 0) {
                            if (gen) {
                                rand = gen.charAt(genIndex);
                                genIndex++;
                            } else {
                                rand = Math.floor(Math.random()*augments.length);
                            }
                            seed+=rand+'_';
                            map[i][j].contents.push($.extend(true, {}, con_aug));
                            map[i][j].obs = buildConfig('config_item');
                            map[i][j].contents[map[i][j].contents.length-1].aug = rand;
                        }
                    } 
                }
            }
        }
        //console.log(seed);
        minimap.update();
        player.x = 9*tileSize;
        player.y = 8*tileSize;
        //console.log(JSON.stringify(cards));
        
        //assign obstacle configs
        for (i=0; i<map.length; i++) {
			for (j=0; j<map[i].length; j++) {
                if (map[i][j] != 0 && map[i][j].obs == -1 && !(i == mapLoc.y && j == mapLoc.x)) {
                    if (gen) {
                        rand = gen.charAt(genIndex);
                        genIndex++;
                    } else {
                        rand = Math.floor(Math.random()*18);
                    }
                    seed+=rand+'_';
                    if (rand != 17) {
                        map[i][j].obs = buildConfig('config_'+rand);
                    }
                    
                }
            }
        }
        
        loadRoom(map[mapLoc.y][mapLoc.x].map);
        lvlComplete = false;
	}
	
    //loads a level
    function loadRoom(level) {
		var rand;
        moves = 0;
        
		map[mapLoc.y][mapLoc.x].discovered = true;
		
        //apply floor style
		for (var i=0; i<map[mapLoc.y][mapLoc.x].map[0].length; i++) {
			for (var j=0; j<map[mapLoc.y][mapLoc.x].map[0][i].length; j++) {
                if (map[mapLoc.y][mapLoc.x].map[0][i][j] != 0) {
                    map[mapLoc.y][mapLoc.x].map[0][i][j] = map[mapLoc.y][mapLoc.x].map[0][i][j]-map[mapLoc.y][mapLoc.x].floorStyle;
                }
            }
        }
        
        //apply wall style
		for (var i=0; i<map[mapLoc.y][mapLoc.x].map[1].length; i++) {
			for (var j=0; j<map[mapLoc.y][mapLoc.x].map[1][i].length; j++) {
                if (map[mapLoc.y][mapLoc.x].map[1][i][j] != 0) {
                    map[mapLoc.y][mapLoc.x].map[1][i][j] = map[mapLoc.y][mapLoc.x].map[1][i][j]-map[mapLoc.y][mapLoc.x].wallStyle;
                }
            }
        }
        
        //insert the obstacle config
        if (map[mapLoc.y][mapLoc.x].obs != -1) {
			for (var k=0; k<3; k++) {
				for (var i=0; i<level[k].length; i++) {
					for (var j=0; j<level[k][i].length; j++) {
						if (map[mapLoc.y][mapLoc.x].obs[k][i][j] !=0) {
							map[mapLoc.y][mapLoc.x].map[k][i][j] = map[mapLoc.y][mapLoc.x].obs[k][i][j];
						}
					}
				}
			}
        }
        
        //build list of placeable spots
		var placeList = [];
		for (var i=0; i<map[mapLoc.y][mapLoc.x].map[1].length; i++) {
			for (var j=0; j<map[mapLoc.y][mapLoc.x].map[1][i].length; j++) {
				if (i>1 && i<map[mapLoc.y][mapLoc.x].map[1].length-1 && j>1 && j<map[mapLoc.y][mapLoc.x].map[1][i].length-1 && map[mapLoc.y][mapLoc.x].map[1][i][j] == 0) {
					placeList.push({x:j, y:i});
				}
			}
		}
		
        //move contents if needed
        for (var i=0; i<map[mapLoc.y][mapLoc.x].contents.length; i++) {
			if (map[mapLoc.y][mapLoc.x].contents[i].type == 'mob' && 
                map[mapLoc.y][mapLoc.x].contents[i].loc.x == -1 && map[mapLoc.y][mapLoc.x].contents[i].loc.y == -1 ||
                map[mapLoc.y][mapLoc.x].contents[i].loc.x < 16 && map[mapLoc.y][mapLoc.x].contents[i].loc.y < 16 ||
                map[mapLoc.y][mapLoc.x].contents[i].loc.x > screenWidth-16 && map[mapLoc.y][mapLoc.x].contents[i].loc.y > screenHeight-32) {
                
				rand = Math.floor(Math.random()*placeList.length);
				map[mapLoc.y][mapLoc.x].contents[i].loc.x = placeList[rand].x*tileSize;
				map[mapLoc.y][mapLoc.x].contents[i].loc.y = placeList[rand].y*tileSize;
			}
            if (map[mapLoc.y][mapLoc.x].contents[i].type == 'key' &&
                level[1][Math.floor(map[mapLoc.y][mapLoc.x].contents[i].loc.y/tileSize)][Math.floor(map[mapLoc.y][mapLoc.x].contents[i].loc.x/tileSize)] != 0) {
                
                rand = Math.floor(Math.random()*placeList.length);
				map[mapLoc.y][mapLoc.x].contents[i].loc.x = placeList[rand].x*tileSize;
				map[mapLoc.y][mapLoc.x].contents[i].loc.y = placeList[rand].y*tileSize;
            }
		}
        if (currLvl!=null) {
            prevLvl = JSON.parse(JSON.stringify(currLvl));
        }
        currLvl = JSON.parse(JSON.stringify(level));
        
        //undo wall styling
        for (var i=0; i<map[mapLoc.y][mapLoc.x].map[1].length; i++) {
			for (var j=0; j<map[mapLoc.y][mapLoc.x].map[1][i].length; j++) {
                if (map[mapLoc.y][mapLoc.x].map[1][i][j] != 0) {
                    map[mapLoc.y][mapLoc.x].map[1][i][j] = map[mapLoc.y][mapLoc.x].map[1][i][j]+map[mapLoc.y][mapLoc.x].wallStyle;
                }
            }
        }
        
        //undo wall styling
        for (var i=0; i<map[mapLoc.y][mapLoc.x].map[0].length; i++) {
			for (var j=0; j<map[mapLoc.y][mapLoc.x].map[0][i].length; j++) {
                if (map[mapLoc.y][mapLoc.x].map[0][i][j] != 0) {
                    map[mapLoc.y][mapLoc.x].map[0][i][j] = map[mapLoc.y][mapLoc.x].map[0][i][j]+map[mapLoc.y][mapLoc.x].floorStyle;
                }
            }
        }
    }
    
    //draw a sprite
	function drawSprite(sprite,x,y) {
        draws++;
        if (sprite == 286 && blink == true) {
            sprite = 318;
        }
        if (sprite == 287 && blink == true) {
            sprite = 319;
        }
        if (sprite == 288 && blink == true) {
            sprite = 320;
        }
        if (sprite == 352 && blink == false) {
            sprite = 384;
        }
        if (sprite == 438 && blink == false) {
            sprite = 470;
        }
        if (sprite == 283 && blink == true) {
            sprite = 315;
        }
        if (sprite == 284 && blink == true) {
            sprite = 316;
        }
        if (sprite == 285 && blink == true) {
            sprite = 317;
        }
        if (sprite == 468 && blink == false && 
            (player.x+4 > x && player.x+4 <= x+8) && 
            (player.y+8 > y && player.y+8 <= y+8)){
            sprite = 434;
        }
        if (sprite == 468 && blink == true && 
            (player.x+4 > x && player.x+4 <= x+8) && 
            (player.y+8 > y && player.y+8 <= y+8)){
            sprite = 466;
        }
        
        sX = Math.floor((sprite-1)/(sheetWidth/8))*8;
		sY = ((sprite-1)%(sheetWidth/8))*8;
            
        /*imgData = lctx.getImageData(sY,sX,8,8);
        curimg = ctx.getImageData(x,y,8,8);

        var equals = true;
        for (var i=0; i<imgData.data.length; i++) {
            if (imgData.data[i] != curimg.data[i]) {
                equals = false;
                break;
            }
        }
        
        //rctx.putImageData(curimg,0,0);
        if (equals == false) {
            //ctx.putImageData(imgData,x,y);   
            ctx.drawImage(spriteSheet, sY,sX,8,8,x,y,8,8);
        }*/
        ctx.drawImage(spriteSheet, sY,sX,8,8,x,y,8,8);
	}
	
    //game window management
    function manageScreen() {
        if ($(window).width() < $(window).height()) {
			canvasWidth = $(window).width();
			canvasHeight = Math.floor((144/160)*($(window).width()));	
		} else {
			canvasHeight = $(window).height();
			canvasWidth = Math.floor((160/144)*($(window).height()));
		}
		rendCanvas.style.top = JSON.stringify(($(window).height()/2)-(canvasHeight/2))+'px';
		rendCanvas.style.left = JSON.stringify(($(window).width()/2)-(canvasWidth/2))+'px';
		rendCanvas.height = JSON.stringify(canvasHeight);
		rendCanvas.width = JSON.stringify(canvasWidth);
		rendCanvas.style.position = 'absolute';
		rctx.imageSmoothingEnabled = false;
        scaleFactor = (canvasWidth/160);
    }
    
    //manage status bar and menu
    function menuSystem() {
        var sX,sY;
        rctx.font="7px monospace";
        if (bannerCounter > -1) {
            bannerCounter++;
            if (bannerCounter > 120) {
                bannerCounter = -1;
            }
        }
        
        if (bannerCounter < 120 && bannerCounter > -1) {
            rctx.fillStyle = 'black';
            rctx.fillRect(0, 0, 64, 8);
            
            rctx.fillStyle = 'white';
            rctx.fillText('Cycle: '+depth, 2, 6);
        }
        
        //pause screen
        if (paused == true) {
            if (menu == true) {
                if (menuHeight > 0) {
                    menuHeight = menuHeight -20;
                }
            } else {
                if (menu < screenHeight-16) {
                    menuHeight = menuHeight+20;
                }
                if (menuHeight >= screenHeight-16) {
                    paused = false;
                }
            }
            rctx.fillStyle = 'black';
            rctx.fillRect(Math.floor(screenWidth/2), menuHeight,Math.floor(screenWidth/2), Math.floor(screenHeight)-16-menuHeight);
            
            //stats
            //lvl dpt
            //dmg def
            //spd crs
            //hp  sp
            rctx.fillStyle = 'white';
            rctx.fillText('lvl: '+player.lvl,Math.floor(screenWidth/2)+4,menuHeight+24);
            rctx.fillText('cycle: '+depth,Math.floor(screenWidth/2)+40,menuHeight+24);
            rctx.fillText('dmg: '+(player.base_damage).toFixed(2),Math.floor(screenWidth/2)+4,menuHeight+32);
            rctx.fillText('def: '+(player.base_defense).toFixed(2),Math.floor(screenWidth/2)+40,menuHeight+32);
            rctx.fillText('spd: '+(player.speed).toFixed(2),Math.floor(screenWidth/2)+4,menuHeight+40);
            rctx.fillText('crs: '+(player.curse).toFixed(2),Math.floor(screenWidth/2)+40,menuHeight+40);
            rctx.fillText('hpr: '+(100*player.healthGen).toFixed(2),Math.floor(screenWidth/2)+4,menuHeight+48);
            rctx.fillText('spr: '+(10*player.spiritGen).toFixed(2),Math.floor(screenWidth/2)+40,menuHeight+48);
            
            rctx.fillText('Augments:',Math.floor(screenWidth/2)+4,menuHeight+60);
            
            for (var i=0; i<player.augments.length; i++) {
                rctx.fillText(player.augments[i].name,Math.floor(screenWidth/2)+4,menuHeight+68+(i*8));
				rctx.fillText(player.augments[i].effectText,Math.floor(screenWidth/2)+40,menuHeight+68+(i*8));
            }
        
            //minimap
            for (var i=0; i<minimap.map.length; i++) {
                for(var j=0; j<minimap.map[i].length; j++) {
                    
                    //if (map[i][j].discovered == true) {
                        sX = Math.floor((minimap.map[i][j]-1)/(sheetWidth/8))*8;
                        sY = ((minimap.map[i][j]-1)%(sheetWidth/8))*8;
                        rctx.drawImage(spriteSheet, sY,sX,8,8,(8*j)+(4*8)-(mapLoc.x*8),menuHeight+(8*i)+(8*8)-(mapLoc.y*8),8,8);
                        //drawSprite(minimap.map[i][j],(8*j)+(4*8)-(mapLoc.x*8),menuHeight+(8*i)+(8*8)-(mapLoc.y*8));
                        if (i == goalTile.y && j == goalTile.x) {
                            sX = Math.floor((757-1)/(sheetWidth/8))*8;
                            sY = ((757-1)%(sheetWidth/8))*8;
                            rctx.drawImage(spriteSheet, sY,sX,8,8,(8*j)+(4*8)-(mapLoc.x*8),menuHeight+(8*i)+(8*8)-(mapLoc.y*8),8,8);
                            //drawSprite(757, (8*j)+(4*8)-(mapLoc.x*8),menuHeight+(8*i)+(8*8)-(mapLoc.y*8));
                        }
                        if (i == mapLoc.y && j == mapLoc.x) {
                            sX = Math.floor((758-1)/(sheetWidth/8))*8;
                            sY = ((758-1)%(sheetWidth/8))*8;
                            rctx.drawImage(spriteSheet, sY,sX,8,8,4*8,menuHeight+(8*8),8,8);
                            //drawSprite(758, 4*8,menuHeight+(8*8));
                        }
                    //}
                }
            }
        }
        
        //status bar
        rctx.fillStyle = 'black';
        rctx.fillRect(0, screenHeight-16, screenWidth, 16);
        
        rctx.fillStyle = 'white';
        rctx.fillText('HP[',0,screenHeight-10);
        for (var i=0; i<player.maxHealth; i++) {
            if (i<player.health) {
                rctx.fillText('|',(i+5)*2,screenHeight-10);
            } else {
                rctx.fillText(' ',(i+5)*2,screenHeight-10);
            }
        }
        rctx.fillText(']',(player.maxHealth+5.5)*2,screenHeight-10);
        
        rctx.fillText('SP[',0,screenHeight-2);
        for (var i=0; i<player.maxSpirit; i++) {
            if (i<player.spirit) {
                rctx.fillText('|',(i+5)*2,screenHeight-2);
            } else {
                rctx.fillText(' ',(i+5)*2,screenHeight-2);
            }
        }
        rctx.fillText(']',(player.maxSpirit+5.5)*2,screenHeight-2);
        
        //ctx.fillText((player.x).toFixed(2)+','+(player.y).toFixed(2)+'; ', screenWidth-80, screenHeight-9);
        //ctx.fillText('p:'+points, 0, screenHeight-2);
        rctx.fillText(fps,screenWidth-15,screenHeight-9);
        
        if (remKeys == 0) {
            sX = Math.floor((549-1)/(sheetWidth/8))*8;
            sY = ((549-1)%(sheetWidth/8))*8;
            rctx.drawImage(spriteSheet, sY,sX,8,8,screenWidth-80,screenHeight-8,8,8);
            //drawSprite(549, screenWidth-80,screenHeight-8);
        } else {
            sX = Math.floor((550-1)/(sheetWidth/8))*8;
            sY = ((550-1)%(sheetWidth/8))*8;
            rctx.drawImage(spriteSheet, sY,sX,8,8,screenWidth-80,screenHeight-8,8,8);
            //drawSprite(550, screenWidth-80,screenHeight-8);
        }
        rctx.fillText(':'+player.keys.length,screenWidth-72,screenHeight-2);
        
        sX = Math.floor((551-1)/(sheetWidth/8))*8;
        sY = ((551-1)%(sheetWidth/8))*8;
        rctx.drawImage(spriteSheet, sY,sX,8,8,screenWidth-80,screenHeight-15,8,8);
        //drawSprite(551, screenWidth-80,screenHeight-15);
        rctx.fillText(':'+remMobs,screenWidth-72,screenHeight-10);
        
        rctx.fillText('XP[',screenWidth-50,screenHeight-2);
        for (var i=0; i<10; i++) {
            if (i<player.exp) {
                rctx.fillText('|',screenWidth-50+(i+5)*2,screenHeight-2);
            } else {
                rctx.fillText(' ',screenWidth-50+(i+5)*2,screenHeight-2);
            }
        }
        rctx.fillText(']: '+player.lvl,screenWidth-50+(10+5.5)*2,screenHeight-2);
        
        rctx.fillText('CR[',screenWidth-50,screenHeight-10);
        for (var i=0; i<10; i++) {
            if (i<player.curse) {
                rctx.fillText('|',screenWidth-50+(i+5)*2,screenHeight-10);
            } else {
                rctx.fillText(' ',screenWidth-50+(i+5)*2,screenHeight-10);
            }
        }
        rctx.fillText(']',screenWidth-50+(10+5.5)*2,screenHeight-10);
    }
    
    //main loop
	function mainLoop() {
        //console.log(lvlComplete);
        frames++;
        //update screen dimensions
        manageScreen();
        
        if (player.health <=0 || player.curse >=10) {
            lvlComplete = true;
            player.health = 0;
            player.spirit = 0;
            player.curse = 0;
            player.keys = [];
            player.x = 0;
            player.y = 0;
            player.exp = 0;
            player.lvl = 0;
        }
        
        if (lvlComplete == false) {
            
            //check for room transitions
            if (Math.floor(player.y-player.speed) <= 1 && mapLoc.y-1 > 0) {
                rTransition = 0;
                roomDrawY = 0-screenHeight+16;
                mapLoc.y--;
                loadRoom(map[mapLoc.y][mapLoc.x].map);
                minimap.update();
            }
            if (Math.ceil(player.y+8+player.speed) >= screenHeight-16 && mapLoc.y+1 < map.length-1) {
                rTransition = 2;
                roomDrawY = screenHeight-16;
                mapLoc.y++;
                loadRoom(map[mapLoc.y][mapLoc.x].map);
                minimap.update();
            }
            if (Math.floor(player.x-player.speed) <= 1 && mapLoc.x-1 > 0) {
                rTransition = 1;
                roomDrawX = 0-screenWidth;
                mapLoc.x--;
                loadRoom(map[mapLoc.y][mapLoc.x].map);
                minimap.update();
            }
            if (Math.ceil(player.x+8+player.speed) >= screenWidth && mapLoc.x+1 < map[mapLoc.y].length-1) {
                rTransition = 3;
                roomDrawX = screenWidth;
                mapLoc.x++;
                loadRoom(map[mapLoc.y][mapLoc.x].map);
                minimap.update();
            }
			
            if (rTransition != -1) {
                if (rTransition == 0) {
                    player.y =  player.y +10;
                    roomDrawY = roomDrawY+10;
                    if (player.y >= screenHeight-28) {
                        player.y = screenHeight-28;
                    }
                    if (roomDrawY >=0) {
                        roomDrawY = 0;
                    }
                    if (roomDrawY == 0 && player.y == screenHeight-28){
                        rTransition = -1;
                    }
                }
                if (rTransition == 2) {
                    player.y =  player.y -10;
                    roomDrawY = roomDrawY-10;
                    if (player.y <= 9+player.speed) {
                        player.y = 9+player.speed;
                    }
                    if (roomDrawY <=0) {
                        roomDrawY = 0;
                    }
                    if (roomDrawY == 0 && player.y == 9+player.speed){
                        rTransition = -1;
                    }
                }
                if (rTransition == 1) {
                    player.x =  player.x +10;
                    roomDrawX = roomDrawX+10;
                    if (player.x >= screenWidth-9-player.speed) {
                        player.x = screenWidth-9-player.speed;
                    }
                    if (roomDrawX >= 0) {
                        roomDrawX = 0;
                    }
                    if (roomDrawX == 0 && player.x == screenWidth-9-player.speed) {
                        rTransition = -1;
                    }
                }
                if (rTransition == 3) {
                    player.x =  player.x -10;
                    roomDrawX = roomDrawX-10;
                    if (player.x <= 9+player.speed) {
                        player.x = 9+player.speed;
                    }
                    if (roomDrawX <= 0) {
                        roomDrawX = 0;
                    }
                    if (roomDrawX == 0 && player.x == 9+player.speed) {
                        rTransition = -1;
                    }
                }
                if (rTransition == 4) {
                    player.y =  player.y +10;
                    roomDrawY = roomDrawY+10;
                    if (player.y >= 8*tileSize) {
                        player.y = 8*tileSize;
                    }
                    if (roomDrawY >=0) {
                        roomDrawY = 0;
                    }
                    
                    if ((roomDrawY == 0 && player.y == 8*tileSize)){
                        rTransition = -1;
                        bannerCounter = 0;
                    }
                    ctx.font="7px monospace";
                    ctx.fillStyle = 'white';
                    ctx.fillText('LOADING...', (screenWidth/2)-20, ((screenHeight-16)/2)+32);
                }
            }
            
            //render map
			//curr room background
            for (var i=0; i<currLvl[0].length; i++) {
                for (var j=0; j<currLvl[0][i].length; j++) {
                    if (currLvl[0][i][j] !=0) {
						drawSprite(currLvl[0][i][j],roomDrawX+Math.floor((j*8)),roomDrawY+Math.floor((i*8)));
					}
                }
            }
            //prev room background
            if (rTransition != -1) {
                for (var i=0; i<prevLvl[0].length; i++) {
                    for (var j=0; j<prevLvl[0][i].length; j++) {
                        if (prevLvl[0][i][j] !=0) {
                            if (rTransition == 0) {
                                drawSprite(prevLvl[0][i][j],roomDrawX+Math.floor((j*8)),roomDrawY+screenHeight-16+Math.floor((i*8)));
                            }
                            if (rTransition == 1) {
                                drawSprite(prevLvl[0][i][j],roomDrawX+screenWidth+Math.floor((j*8)),roomDrawY+Math.floor((i*8)));
                            }
                            if (rTransition == 2) {
                                drawSprite(prevLvl[0][i][j],roomDrawX+Math.floor((j*8)),roomDrawY-screenHeight+16+Math.floor((i*8)));
                            }
                            if (rTransition == 3) {
                                drawSprite(prevLvl[0][i][j],roomDrawX-screenWidth+Math.floor((j*8)),roomDrawY+Math.floor((i*8)));
                            }
                        }
                    }
                }
            }
			
			//curr room collision
            for (var i=0; i<currLvl[1].length; i++) {
                for (var j=0; j<currLvl[1][i].length; j++) {
                    if (currLvl[1][i][j] !=0) {
						drawSprite(currLvl[1][i][j],roomDrawX+Math.floor((j*8)),roomDrawY+Math.floor((i*8)));
					}
                }
            }
            //prev room collision
            if (rTransition != -1) {
                for (var i=0; i<prevLvl[1].length; i++) {
                    for (var j=0; j<prevLvl[1][i].length; j++) {
                        if (prevLvl[1][i][j] !=0) {
                            if (rTransition == 0) {
                                drawSprite(prevLvl[1][i][j],roomDrawX+Math.floor((j*8)),roomDrawY+screenHeight-16+Math.floor((i*8)));
                            }
                            if (rTransition == 1) {
                                drawSprite(prevLvl[1][i][j],roomDrawX+screenWidth+Math.floor((j*8)),roomDrawY+Math.floor((i*8)));
                            }
                            if (rTransition == 2) {
                                drawSprite(prevLvl[1][i][j],roomDrawX+Math.floor((j*8)),roomDrawY-screenHeight+16+Math.floor((i*8)));
                            }
                            if (rTransition == 3) {
                                drawSprite(prevLvl[1][i][j],roomDrawX-screenWidth+Math.floor((j*8)),roomDrawY+Math.floor((i*8)));
                            }
                        }
                    }
                }
            }

			//update the player and room contents
			if (paused == false && rTransition == -1) {	
                //update contents of room
                for (var i=0; i<map[mapLoc.y][mapLoc.x].contents.length; i++) {
                    map[mapLoc.y][mapLoc.x].contents[i].action();
                }
                
                player.update();    
			}
            
            //draw the contents of the room
            if (rTransition == -1) {
                for (var i=0; i<map[mapLoc.y][mapLoc.x].contents.length; i++) {
                    map[mapLoc.y][mapLoc.x].contents[i].draw();
                }
            }
                        
            //ctx.fillStyle = 'red';
			//ctx.fillRect(player.x,player.y,8,8);
            player.draw();
            
            //curr room overlap
            for (var i=0; i<currLvl[2].length; i++) {
                for (var j=0; j<currLvl[2][i].length; j++) {
                    if (currLvl[2][i][j] !=0) {
						drawSprite(currLvl[2][i][j],roomDrawX+Math.floor((j*8)),roomDrawY+Math.floor((i*8)));
					}
                }
            }
            
            //prev room overlap
            if (rTransition != -1) {
                for (var i=0; i<prevLvl[2].length; i++) {
                    for (var j=0; j<prevLvl[2][i].length; j++) {
                        if (prevLvl[2][i][j] !=0) {
                            if (rTransition == 0) {
                                drawSprite(prevLvl[2][i][j],roomDrawX+Math.floor((j*8)),roomDrawY+screenHeight-16+Math.floor((i*8)));
                            }
                            if (rTransition == 1) {
                                drawSprite(prevLvl[2][i][j],roomDrawX+screenWidth+Math.floor((j*8)),roomDrawY+Math.floor((i*8)));
                            }
                            if (rTransition == 2) {
                                drawSprite(prevLvl[2][i][j],roomDrawX+Math.floor((j*8)),roomDrawY-screenHeight+16+Math.floor((i*8)));
                            }
                            if (rTransition == 3) {
                                drawSprite(prevLvl[2][i][j],roomDrawX-screenWidth+Math.floor((j*8)),roomDrawY+Math.floor((i*8)));
                            }
                        }
                    }
                }
            }
                
        } else {
			//render game over screen
            bgm.stop();
            if (player.health <=0) {
                ctx.font="7px monospace";
                ctx.fillStyle = 'black';
                ctx.fillRect(0,0,screenWidth,screenHeight-16);
                ctx.fillStyle = 'white';
                ctx.fillText('GAME OVER', (screenWidth/2)-20, ((screenHeight-16)/2));
                ctx.fillText('Press Space to Retry', (screenWidth/2)-40, ((screenHeight-16)/2)+8);
                
                if (pressedKeys.indexOf('_') > -1) {
                    init();
                }
            } else {
            
            }
                
        }
		
        //apply pallette swap
        img = ctx.getImageData(0,0,160,144-16);
        if (palettesEnabled == true) {
            
            for(var i = 0, l = img.data.length; i < l; i += 4) {
                if (img.data[i+3] > 0) {
                    if (img.data[i] == pal_0[0][0] && img.data[i+1] == pal_0[0][1] && img.data[i+2] == pal_0[0][2]) {
                    
                        img.data[i] = currPal[0][0];
                        img.data[i+1] = currPal[0][1];
                        img.data[i+2] = currPal[0][2];
                    }
                    if (img.data[i] == pal_0[1][0] && img.data[i+1] == pal_0[1][1] && img.data[i+2] == pal_0[1][2]) {
                    
                        img.data[i] = currPal[1][0];
                        img.data[i+1] = currPal[1][1];
                        img.data[i+2] = currPal[1][2];
                    }
                    if (img.data[i] == pal_0[2][0] && img.data[i+1] == pal_0[2][1] && img.data[i+2] == pal_0[2][2]) {
                    
                        img.data[i] = currPal[2][0];
                        img.data[i+1] = currPal[2][1];
                        img.data[i+2] = currPal[2][2];
                    }
                    if (img.data[i] == pal_0[3][0] && img.data[i+1] == pal_0[3][1] && img.data[i+2] == pal_0[3][2]) {
                    
                        img.data[i] = currPal[3][0];
                        img.data[i+1] = currPal[3][1];
                        img.data[i+2] = currPal[3][2];
                    }
                } 
            } 
            
        }
        ctx.putImageData(img, 0, 0);
        rendScreen = ctx.getImageData(0,0,screenWidth,screenHeight);
        rctx.putImageData(rendScreen,0,0);
        rctx.scale(scaleFactor,scaleFactor);
        rctx.drawImage(rendCanvas, 0,0);
        //update/render menu
        menuSystem();
        rctx.scale(1/scaleFactor,1/scaleFactor);
        
        drawsperframe = draws;
        draws = 0;
        
        window.requestAnimationFrame(mainLoop);
	}
    
    //Fisher-Yates shuffle
    function shuffle(array) {
        var m = array.length, t, i;

        // While there remain elements to shuffle…
        while (m) {

            // Pick a remaining element…
            i = Math.floor(Math.random() * m--);

            // And swap it with the current element.
            t = array[m];
            array[m] = array[i];
            array[i] = t;
        }
    }
</script>
</html>
