<!DOCTYPE HTML>
<html>
<head>
	<script src="https://code.jquery.com/jquery-1.10.2.js"></script>
</head>
<body bgcolor="#787878">
<canvas id="myCanvas" height="720" width="800" style="border:1px solid black;"></canvas>


<script type="text/javascript">
    var blink = true;			//state of blink
    var frames = 0;				//A frame count
    var goalTile = {x:-1,y:-1};	//Exit Tile	
    var lvlComplete = false;	//Status of competion
	var canvasHeight = 576;
	var canvasWidth = 640;
    var screenWidth = 160;		//Game Resolution Width
    var screenHeight = 144;		//Game Resolution Height
	var tileSize = 8;			//size of tiles
	var scaleFactor = 5;			//screen scaling factor
    var lvlWidth = screenWidth/tileSize;		//width of room
    var lvlHeight = (screenHeight/tileSize)-2;	//height of room
	var sheetWidth = 256;		//width and height of sprite sheet
    var points = 0;				//count of points
    var cards = [];				//List of coin objects
    var moves = 0;				//count of moves
	var search = [];			//list of connected tiles
    var fps = 60;					//count of frames per second
	var pressedKeys = [];		//list of accepted key presses at a given time
    var hasAug = -1;
    var difficulty = 1;
	var paused = false;
    var depth = -1;
    var menuHeight = screenHeight-16;
    var menu = false;
    var rTransition = -1;
    var roomDrawY = 0;
    var roomDrawX = 0;
    var currLvl;
    var prevLvl;
    var spriteSet = 0;
    var bannerCounter = 0;
    
    var spriteSheet = new Image();	//Sheet of sprite images
	spriteSheet.src = 'assets/char_sheet.png';
    
    var playerSheet = new Image();
    playerSheet.src = 'assets/player_sheet.png';
    
    //initiate canvas
	var canvas = document.getElementById("myCanvas");
	var ctx = canvas.getContext("2d");
	ctx.imageSmoothingEnabled = false;
    
    var map = [[]];
    var mapLoc = {x:0, y:0};
    
    var minimap = { display:false, 
                    map:[],
                    update: function() {
                                var newRow = [];
                                minimap.map = [];
                                for (var i=0; i<map.length; i++) {
                                    newRow = [];
                                    for (var j=0; j<map[i].length; j++) {
                                        newRow.push(minimap.convert(map[i][j].config));
                                    }
                                    minimap.map.push(newRow);
                                }
                            },
                    convert:    function(rawConfig) {
                                    var config = [];
                                    if (rawConfig != null) {
                                        for (var i=0; i<rawConfig.length; i++) {
                                            if (rawConfig[i].length > 0) {
                                                config[i] = 1;
                                            } else {
                                                config[i] = 0;
                                            }
                                        }
                                    }
                                    config = JSON.stringify(config);
                                    switch (config) {
                                        case    '[1,1,1,1]' :   return 925; break;
                                        case    '[1,0,0,0]' :   return 926; break;
                                        case    '[0,0,1,0]' :   return 927; break;
                                        case    '[0,1,0,0]' :   return 928; break;
                                        case    '[0,0,0,1]' :   return 957; break;
                                        case    '[0,1,0,1]' :   return 958; break;
                                        case    '[1,0,1,0]' :   return 959; break;
                                        case    '[0,0,1,1]' :   return 960; break;
                                        case    '[0,1,1,0]' :   return 989; break;
                                        case    '[1,1,0,0]' :   return 990; break;
                                        case    '[1,0,0,1]' :   return 991; break;
                                        case    '[1,1,0,1]' :   return 992; break;
                                        case    '[0,1,1,1]' :   return 1021; break;
                                        case    '[1,1,1,0]' :   return 1022; break;
                                        case    '[1,0,1,1]' :   return 1023; break;
                                        default             :   return 1024; break;
                                        
                                    }
                                } 
                  
    };
    
    var player={x:9*tileSize,
                y:8*tileSize,
                dir:2,
                strafe: false,
                moving: false,
                attacking: false,
                moveWhileAttacking: false,
                speed: 1,//60/fps,
                speedLimit: 4,
                base_damage:1,
                base_defense:1,
                health:10,
                healthGen:0,
                maxHealth:10,
                healthLimit:32,
                spirit:10,
                spiritGen:.1,
                maxSpirit:10,
                spiritLimit:32,
                curse:0,
                curseGen:.0001,
                maxCurse:10,
                exp:0,
                lvlUp: 5,
                lvl:0,
                newLvl:10,
                augments:[],
				maxAugs: 5,
                animations:{wU_anim:[{x:0,y:112},{x:0,y:176}],
                            wD_anim:[{x:0,y:64},{x:0,y:128}],
                            wL_anim:[{x:0,y:96},{x:0,y:160}],
                            wR_anim:[{x:0,y:80},{x:0,y:144}]
                            },
                anim_index:0,
                animCounter:-1,
                update: function (){
                            
                            if (this.speed > 4) {
                                this.speed = 4;
                            }
                            
                            //regen(?) health
                            this.health+=this.healthGen;
                            if (this.health > this.maxHealth) {
                                this.health = this.maxHealth;
                            }
                            
                            //progress curse
                            this.curse+=this.curseGen;
                            if (this.curse > this.maxCurse) {
                                this.curse = this.maxCurse;
                            }
                            
                            //check on level progression
                            if (this.exp == this.newLvl) {
                                this.lvl++;
                                this.exp = 0;
                                this.maxHealth = this.maxHealth+this.lvlUp;
                                if (this.maxHealth > this.healthLimit) {
                                    this.maxHealth = this.healthLimit;
                                }
                                this.health = this.maxHealth;
                                this.maxSpirit = this.maxSpirit+this.lvlUp;
                                if (this.maxSpirit > this.spiritLimit) {
                                    this.maxSpirit = this.spiritLimit;
                                }
                                //diminishing returns of level ups
                                this.lvlUp = Math.ceil(this.lvl/2);
                            }
                            
                            //check if player should be moving
                            if (pressedKeys.indexOf('W') > -1 || pressedKeys.indexOf('A') > -1 ||
                                pressedKeys.indexOf('S') > -1 || pressedKeys.indexOf('D') > -1) {
                                this.moving = true;
                                if (this.animCounter == -1) {
                                    this.animCounter = 0;
                                }
                            } else {
                                this.moving = false;
                                this.animCounter = -1;
                            }
                            
                            //check if/where the player should be facing
                            if (pressedKeys.indexOf('J') > -1) {
                                this.strafe = true;
                            } else {
                                this.strafe = false;
                            }
                            
                            //use weapon of regen spirit
                            if (this.attacking == true) {
                                if (this.moveWhileAttacking == false) {
                                    this.moving  = false;
                                }
                                this.weapons[this.wepIndex].action();
                            } else {
                                this.spirit = this.spirit+this.spiritGen;
                            }
                            
                            //update the weapon
                            this.weapons[this.wepIndex].update();
                            
                            if (this.spirit > this.maxSpirit) {
                                this.spirit = this.maxSpirit;
                            }
                            
                            for (var i=0; i<pressedKeys.length; i++) {
                                switch (pressedKeys[i]) {
                                    case    'W':    if (this.moving == true) {
                                                        player.move(0);
                                                    }
                                                    break;
                                    case    'A':    if (this.moving == true) {
                                                        player.move(1);
                                                    }
                                                    break;
                                    case    'S':    if (this.moving == true) {
                                                        player.move(2);
                                                    }
                                                    break;
                                    case    'D':    if (this.moving == true) {
                                                        player.move(3);
                                                    }
                                                    break;
									case	'_':	if (this.attacking == false && this.spirit>=this.weapons[this.wepIndex].init_cost) {
                                                        player.attacking = true;
                                                        player.spirit = player.spirit-player.weapons[player.wepIndex].init_cost;
                                                    }
                                                    if (this.attacking == true && player.weapons[this.wepIndex].cont == true){
                                                        this.spirit = this.spirit-player.weapons[this.wepIndex].use_cost;
                                                        if (this.spirit < -1) {
                                                            this.attacking = false;
                                                            this.spirit = -1;
                                                        }
                                                    }
                                                    
													break;
                                }
                            }
                        },
                move:   function (dir) {
                            if (dir == 0) {
                                if (this.strafe == false) {
                                    this.dir = 0;
                                }
                                var canMove = this.speed;
                                if (this.y-this.speed <= 0) {
                                    canMove = 0 - (this.y-this.speed);
                                    if (canMove < 0) {
                                        canMove = 0;
                                    }
                                    this.y-=canMove;
                                } else {
                                    canMove =  .25;
                                    while (canMove < this.speed) {
                                        if (currLvl[1][Math.floor((Math.floor(this.y)-(.25))/8)][Math.floor(Math.floor(this.x)/8)] ==0 &&
                                            currLvl[1][Math.floor((Math.floor(this.y)-(.25))/8)][Math.ceil(Math.ceil(this.x)/8)] ==0) {
                                            console.log('.25');
                                            this.y-=.25;
                                        } else {
                                            break;
                                        }
                                        canMove+=.25;
                                    }
                                    console.log(canMove);
                                }
                                
                            }
                            if (dir == 1) {
                                if (this.strafe == false) {
                                    this.dir = 1;
                                }
                                var canMove = this.speed;
                                if (this.x-this.speed <= 0) {
                                    canMove = 0 - (this.x-this.speed);
                                    if (canMove < 0) {
                                        canMove = 0;
                                    }
                                }
                                if (currLvl[1][Math.floor((Math.floor(this.y))/8)][Math.floor((Math.floor(this.x)-this.speed)/8)] == 0 &&
                                    currLvl[1][Math.ceil(((Math.ceil(this.y)))/8)][Math.floor((Math.floor(this.x)-this.speed)/8)] == 0) {
                                    
                                    this.x-=canMove;
                                }
                            }
                            if (dir == 2) {
                                if (this.strafe == false) {
                                    this.dir = 2;
                                }
                                var canMove = this.speed;
                                if (this.y+this.speed+8 >= screenHeight-16) {
                                    canMove = (this.y+this.speed) - screenHeight-16;
                                    if (canMove < 0) {
                                        canMove = 0;
                                    }
                                }
                                if (currLvl[1][Math.ceil((Math.ceil(this.y)+this.speed)/8)][Math.floor(Math.floor(this.x)/8)] == 0 &&
                                    currLvl[1][Math.ceil((Math.ceil(this.y)+this.speed)/8)][Math.ceil(Math.ceil(this.x)/8)] == 0) {
                                    
                                    this.y+=canMove;
                                }
                            }
                            if (dir == 3) {
                                if (this.strafe == false) {
                                    this.dir = 3;
                                }
                                var canMove = this.speed;
                                if (this.x+this.speed+8 >= screenWidth) {
                                    canMove = (this.x+this.speed) - screenWidth;
                                    if (canMove < 0) {
                                        canMove = 0;
                                    }
                                }
                                if (currLvl[1][Math.ceil(Math.ceil(this.y)/8)][Math.ceil((Math.ceil(this.x)+canMove)/8)] == 0 &&
                                    currLvl[1][Math.floor(Math.floor(this.y)/8)][Math.ceil((Math.ceil(this.x)+canMove)/8)] == 0) {
                                    
                                    this.x+=canMove;
                                }
                            }
                        },
                draw:   function(){
                            if (this.animCounter > -1) {
                                this.animCounter++;
                                if (this.animCounter > 10) {
                                    this.animCounter = 0;
                                    this.anim_index++;
                                }
                            }
                            if (player.dir == 0) {
                                if (this.moving == true && paused == false) {
                                    if (player.anim_index >= player.animations.wU_anim.length) {
										player.anim_index = 0;
									}
                                    ctx.drawImage(playerSheet, player.animations.wU_anim[player.anim_index].x,player.animations.wU_anim[player.anim_index].y,16,16,player.x-4, player.y-8,16,16);
                                    for (var i=0; i<this.augments.length; i++) {
                                        ctx.drawImage(playerSheet, this.augments[i].drawCol,this.animations.wU_anim[this.anim_index].y,16,16,this.x-4, this.y-8,16,16);
                                    }
                                } else {
                                    ctx.drawImage(playerSheet, 0,48,16,16,player.x-4, player.y-8,16,16);
                                    for (var i=0; i<player.augments.length; i++) {
                                        ctx.drawImage(playerSheet, player.augments[i].drawCol,48,16,16,player.x-4, player.y-8,16,16);
                                    }
                                }
                                
                            }
                            if (player.dir == 1) {
                                if (this.moving == true && paused == false) {
									if (player.anim_index >= player.animations.wL_anim.length) {
										player.anim_index = 0;
									}
                                    ctx.drawImage(playerSheet, player.animations.wL_anim[player.anim_index].x,player.animations.wL_anim[player.anim_index].y,16,16,player.x-4, player.y-8,16,16);
                                    for (var i=0; i<player.augments.length; i++) {
                                        ctx.drawImage(playerSheet, player.augments[i].drawCol,player.animations.wL_anim[player.anim_index].y,16,16,player.x-4, player.y-8,16,16);
                                    }
                                } else {
                                    ctx.drawImage(playerSheet, 0,32,16,16,player.x-4, player.y-8,16,16);
                                    for (var i=0; i<player.augments.length; i++) {
                                        ctx.drawImage(playerSheet, player.augments[i].drawCol,32,16,16,player.x-4, player.y-8,16,16);
                                    }
                                }
                                
                            }
                            if (player.dir == 2) {
                                if (this.moving == true && paused == false) {
                                    if (player.anim_index >= player.animations.wD_anim.length) {
                                        player.anim_index = 0;
                                    }
                                    ctx.drawImage(playerSheet, player.animations.wD_anim[player.anim_index].x,player.animations.wD_anim[player.anim_index].y,16,16,player.x-4, player.y-8,16,16);
                                    for (var i=0; i<player.augments.length; i++) {
                                        ctx.drawImage(playerSheet, player.augments[i].drawCol,player.animations.wD_anim[player.anim_index].y,16,16,player.x-4, player.y-8,16,16);
                                    }
                                } else {
                                    ctx.drawImage(playerSheet, 0,0,16,16,player.x-4, player.y-8,16,16);
                                    for (var i=0; i<player.augments.length; i++) {
                                        ctx.drawImage(playerSheet, player.augments[i].drawCol,0,16,16,player.x-4, player.y-8,16,16);
                                    }
                                }
                            }
                            if (player.dir == 3) {
                                if (this.moving == true && paused == false) {   
                                    if (player.anim_index >= player.animations.wR_anim.length) {
                                        player.anim_index = 0;
                                    }
                                    ctx.drawImage(playerSheet, player.animations.wR_anim[player.anim_index].x,player.animations.wR_anim[player.anim_index].y,16,16,player.x-4, player.y-8,16,16);
                                    for (var i=0; i<player.augments.length; i++) {
                                        ctx.drawImage(playerSheet, player.augments[i].drawCol,player.animations.wR_anim[player.anim_index].y,16,16,player.x-4, player.y-8,16,16);
                                    }
                                } else {
                                    ctx.drawImage(playerSheet, 0,16,18,16,player.x-4, player.y-8,16,16);
                                    for (var i=0; i<player.augments.length; i++) {
                                        ctx.drawImage(playerSheet, player.augments[i].drawCol,16,18,16,player.x-4, player.y-8,16,16);
                                    }
                                }
                            }
                        },
                keys:[],
				wepIndex: 0,
				weapons:[]
    };
    
	var wep_test = 	{   init_cost: 4,
                        cont: true,
                        use_cost: .1,
                        knockback: 8,
                        aoe: [[{x: -8, y: 0, sprite: 33, dur:4, dirXadj: 8, dirYadj: 0},{x: -8, y: -8, sprite: 1, dur:4, dirXadj: 8, dirYadj: 8},{x: 0, y: -8, sprite: 2, dur:4, dirXadj: 0, dirYadj: 8}],
                              [{x: 0, y: +8, sprite: 66, dur:4, dirXadj: 0, dirYadj: 0},{x: -8, y: +8, sprite: 65, dur:4, dirXadj: 8, dirYadj: 0},{x: -8, y: 0, sprite: 33, dur:4, dirXadj: 8, dirYadj: 8}],
                              [{x: +8, y: 0, sprite: 35, dur:4, dirXadj: 0, dirYadj: 8},{x: +8, y: +8, sprite: 67, dur:4, dirXadj: 0, dirYadj: 0},{x: 0, y: +8, sprite: 66, dur:4, dirXadj: 8, dirYadj: 0}],
                              [{x: 0, y: -8, sprite: 2, dur:4, dirXadj: 8, dirYadj: 8},{x: +8, y: -8, sprite: 3, dur:4, dirXadj: 0, dirYadj: 8},{x: +8, y: 0, sprite: 35, dur:4, dirXadj: 0, dirYadj: 0}]
                             ],
                        damage: 1,
                        durCount:0,
                        atkIndex:0,
                        actioning: false,
                        update: function() {
                                    
                                    if (this.actioning == true) {
                                        this.durCount++;
                                        
                                        drawSprite(this.aoe[player.dir][this.atkIndex].sprite, player.x+this.aoe[player.dir][this.atkIndex].x, player.y+this.aoe[player.dir][this.atkIndex].y);
                                        for (var i=0; i<map[mapLoc.y][mapLoc.x].contents.length; i++) {
                                            if (map[mapLoc.y][mapLoc.x].contents[i].type == 'mob') {
                                                
                                                if (map[mapLoc.y][mapLoc.x].contents[i].alive == true &&
                                                    ((map[mapLoc.y][mapLoc.x].contents[i].loc.x+8 >= player.x+this.aoe[player.dir][this.atkIndex].x && 
                                                    map[mapLoc.y][mapLoc.x].contents[i].loc.x+8 < player.x+this.aoe[player.dir][this.atkIndex].x+tileSize) ||
                                                    (map[mapLoc.y][mapLoc.x].contents[i].loc.x >= player.x+this.aoe[player.dir][this.atkIndex].x && 
                                                    map[mapLoc.y][mapLoc.x].contents[i].loc.x < player.x+this.aoe[player.dir][this.atkIndex].x+tileSize)) &&
                                                    ((map[mapLoc.y][mapLoc.x].contents[i].loc.y+8 >= player.y+this.aoe[player.dir][this.atkIndex].y && 
                                                    map[mapLoc.y][mapLoc.x].contents[i].loc.y+8 < player.y+this.aoe[player.dir][this.atkIndex].y+tileSize) ||
                                                    (map[mapLoc.y][mapLoc.x].contents[i].loc.y >= player.y+this.aoe[player.dir][this.atkIndex].y && 
                                                    map[mapLoc.y][mapLoc.x].contents[i].loc.y < player.y+this.aoe[player.dir][this.atkIndex].y+tileSize))) {
                                                    
                                                    map[mapLoc.y][mapLoc.x].contents[i].health = map[mapLoc.y][mapLoc.x].contents[i].health-(player.base_damage+this.damage);
                                                    ctx.fillStyle = 'red';
                                                    ctx.fillRect(map[mapLoc.y][mapLoc.x].contents[i].loc.x, map[mapLoc.y][mapLoc.x].contents[i].loc.y, tileSize, tileSize);
                                                    if (player.dir == 0 && currLvl[1][Math.floor((map[mapLoc.y][mapLoc.x].contents[i].loc.y+4-this.knockback)/tileSize)][Math.floor((map[mapLoc.y][mapLoc.x].contents[i].loc.x+4)/tileSize)] == 0) {
                                                        map[mapLoc.y][mapLoc.x].contents[i].loc.y = map[mapLoc.y][mapLoc.x].contents[i].loc.y-this.knockback;
                                                    }
                                                    if (player.dir == 1 && currLvl[1][Math.floor((map[mapLoc.y][mapLoc.x].contents[i].loc.y+4)/tileSize)][Math.floor((map[mapLoc.y][mapLoc.x].contents[i].loc.x+4-this.knockback)/tileSize)] == 0) {
                                                        map[mapLoc.y][mapLoc.x].contents[i].loc.x = map[mapLoc.y][mapLoc.x].contents[i].loc.x-this.knockback;
                                                    }
                                                    if (player.dir == 2 && currLvl[1][Math.floor((map[mapLoc.y][mapLoc.x].contents[i].loc.y+4+this.knockback)/tileSize)][Math.floor((map[mapLoc.y][mapLoc.x].contents[i].loc.x+4)/tileSize)] == 0) {
                                                        map[mapLoc.y][mapLoc.x].contents[i].loc.y = map[mapLoc.y][mapLoc.x].contents[i].loc.y+this.knockback;
                                                    }
                                                    if (player.dir == 3 && currLvl[1][Math.floor((map[mapLoc.y][mapLoc.x].contents[i].loc.y+4)/tileSize)][Math.floor((map[mapLoc.y][mapLoc.x].contents[i].loc.x+4+this.knockback)/tileSize)] == 0) {
                                                        map[mapLoc.y][mapLoc.x].contents[i].loc.x = map[mapLoc.y][mapLoc.x].contents[i].loc.x+this.knockback;
                                                    }
                                                }
                                            }
                                        }
                                        //player.attacking = false;
                                        
                                        if (this.durCount >= this.aoe[player.dir][this.atkIndex].dur) {
                                            this.durCount = 0;
                                            this.atkIndex++;
                                            if (this.atkIndex >= this.aoe[player.dir].length) {
                                                this.atkIndex = 0;
                                                this.actioning = false;
                                            }
                                        }
                                    }
                                },
                        action:	function() {
                                    if (this.actioning == false) {
                                        this.actioning = true;
                                        this.durCount = 0;
                                    }
								}
					};
					
	player.weapons.push(wep_test);
	
    {//augments
        var aug_scarf = 	{name: 'Scarf', effectText: '+.25 spd', drawCol: 16, onPickup: function(){player.speed = player.speed+.25;}, 			onDrop:	function(){player.speed = player.speed-.25;}, 				action:   function(){}};
        var aug_heartPin = 	{name: 'Pin',	effectText: '+.005 hpr', drawCol: 32, onPickup: function() {player.healthGen = player.healthGen+.005;}, 	onDrop:	function(){player.healthGen = player.healthGen-.005;}, 		action:    function(){}};
        var aug_bracelet = 	{name: 'Brace',	effectText: '+.1 spr', drawCol: 48, onPickup: function(){player.spiritGen = player.spiritGen+.1;}, 	onDrop:	function(){player.spiritGen = player.spiritGen-.1;}, 		action:    function(){}};
        var aug_tabard = 	{name: 'Tabard',effectText: '+move+atk', drawCol: 64, onPickup: function(){player.moveWhileAttacking = true;}, onDrop:	function(){player.moveWhileAttacking = false;},	action:    function(){}};
        var aug_robe = 		{name: 'Robe',	effectText: '+3 def', drawCol: 80, onPickup: function(){player.base_defense = player.base_defense+1}, onDrop:	function(){player.base_defense = player.base_defense-1}, action:    function(){}};
        var aug_horns = 	{name: 'Horns',	effectText: '+1 dmg', drawCol: 96, onPickup: function(){player.base_damage = player.base_damage+1}, 	onDrop:	function(){player.base_damage = player.base_damage-1}, 		action:    function(){}};
    }
    var augments = [aug_scarf,aug_heartPin,aug_bracelet,aug_tabard,aug_robe,aug_horns,aug_scarf];
    
    {//room items
        var con_mob = {type: 'mob', sprite: [705], loc: {x: -1, y:-1}, speed: 1, health: 10, alive: true, exp_reward: 1,
                        damage: .5,
                        cursePenalty: 1,
                        action:	function() {
                                    if (this.health <= 0 && this.alive == true) {
                                        player.exp = player.exp+this.exp_reward;
                                        player.curse = player.curse + this.cursePenalty;
                                        this.alive = false;
                                    }
                                    if (this.alive == true) {
                                        
                                        var rand = Math.floor(Math.random()*8);
                                        
                                        if (rand == 0) {
                                            this.speed = 1.5;
                                            if ((this.loc.x - player.x) > 0) {
                                                rand = 1;
                                            } else {
                                                rand = 3;
                                            }
                                        } else if (rand == 1){
                                            this.speed = 1.5;
                                            if ((this.loc.y - player.y) > 0) {
                                                rand = 0;
                                            } else {
                                                rand = 2;
                                            }
                                        } else {
                                            this.speed  = 1;
                                            rand = Math.floor(Math.random()*4);
                                        }
                                        
                                        if (rand == 0) {
                                            if (this.loc.y >= 16 
                                                && currLvl[1][Math.floor((Math.floor(this.loc.y)-.5)/8)][Math.floor(Math.floor(this.loc.x)/8)] ==0
                                                && currLvl[1][Math.floor((Math.floor(this.loc.y)-.5)/8)][Math.ceil(Math.ceil(this.loc.x)/8)] ==0) {
                                                this.loc.y-=this.speed;
                                            }
                                        }
                                        if (rand == 1) {
                                            if (this.loc.x >= 16 
                                                && currLvl[1][Math.floor((Math.floor(this.loc.y))/8)][Math.floor((Math.floor(this.loc.x)-.5)/8)] == 0
                                                && currLvl[1][Math.ceil(((Math.ceil(this.loc.y)))/8)][Math.floor((Math.floor(this.loc.x)-.5)/8)] == 0) {
                                                this.loc.x-=this.speed;
                                            }
                                        }
                                        if (rand == 2) {
                                            if (this.loc.y+8 < screenHeight-32 
                                                && currLvl[1][Math.ceil((Math.ceil(this.loc.y)+.5)/8)][Math.floor(Math.floor(this.loc.x)/8)] == 0
                                                && currLvl[1][Math.ceil((Math.ceil(this.loc.y)+.5)/8)][Math.ceil(Math.ceil(this.loc.x)/8)] == 0) {
                                                this.loc.y+=this.speed;
                                            }
                                        }
                                        if (rand == 3) {
                                            if (this.loc.x+8 < screenWidth-16
                                                && currLvl[1][Math.ceil(Math.ceil(this.loc.y)/8)][Math.ceil((Math.ceil(this.loc.x)+.5)/8)] == 0
                                                && currLvl[1][Math.floor(Math.floor(this.loc.y)/8)][Math.ceil((Math.ceil(this.loc.x)+.5)/8)] == 0) {
                                                this.loc.x+=this.speed;
                                            }
                                        }
                                        
                                        if (player.x <= (this.loc.x)+8 &&  player.x > (this.loc.x)-8 && player.y <= (this.loc.y)+8 &&  player.y > (this.loc.y)-8) {
                                            player.health = player.health-(this.damage-player.base_defense/10);
                                            if (player.dir == 0 && currLvl[1][Math.floor((player.y+8)/tileSize)][Math.floor((player.x)/tileSize)] == 0) {
                                                player.y+=8;
                                            }
                                            if (player.dir == 1 && currLvl[1][Math.floor((player.y)/tileSize)][Math.floor((player.x+8)/tileSize)] == 0) {
                                                player.x+=8;
                                            }
                                            if (player.dir == 2 && currLvl[1][Math.floor((player.y-8)/tileSize)][Math.floor((player.x)/tileSize)] == 0) {
                                                player.y-=8;
                                            }
                                            if (player.dir == 3 && currLvl[1][Math.floor((player.y)/tileSize)][Math.floor((player.x-8)/tileSize)] == 0) {
                                                player.x-=8;
                                            }
                                        }
                            }
                            
                        },
                        draw:	function() {
                                    if (this.alive == true) {
                                        drawSprite(this.sprite[0], this.loc.x, this.loc.y);
                                    }
                                }
        };
        var con_aug = {type: 'aug', sprite: [582,583], loc: {x: 9*tileSize, y: 8*tileSize}, collected: false,
                        action:	function() {
                            if (player.x <= (this.loc.x)+4 && player.x > (this.loc.x)-4 && 
                                player.y <= (this.loc.y)+4 && player.y > (this.loc.y)-4 &&
                                this.collected == false) {
                                player.augments.unshift(augments[this.aug]);
								if (player.augments.length > player.maxAugs) {
									player.augments[player.augments.length-1].onDrop();
									player.augments.pop();
								}
                                augments[this.aug].onPickup();
                                this.collected = true;
                            }
                        },
                        draw:	function() {
                                    if (this.collected == false) {	
                                        drawSprite(this.sprite[0], this.loc.x, this.loc.y);
                                    }
                                },
                        aug: -1
        };
        var con_key = {type: 'key', sprite: [549], loc: {x: 9*tileSize, y: 8*tileSize}, collected: false,
                        action:	function() {
                                    if (player.x <= (this.loc.x)+4 && player.x > (this.loc.x)-4 && 
                                        player.y <= (this.loc.y)+4 && player.y > (this.loc.y)-4 &&
                                        this.collected == false) {
                                        player.keys.push(this);
                                        this.collected = true;
                                    }
                                },
                        draw:	function() {
                                    if (this.collected == false) {	
                                        drawSprite(this.sprite[0], this.loc.x, this.loc.y);
                                    }
                                }
        };
        var con_goal = {type: 'goal', sprite: [581], loc: {x: 9.5*tileSize, y: 8*tileSize},
                        action:	function() {
                            if (player.x <= (this.loc.x)+4 && player.x > (this.loc.x)-4 && player.y <= (this.loc.y)+4 && player.y > (this.loc.y)-4 
                                && (player.keys.length >= this.diff)) {
                                lvlComplete = true;
								var rand = Math.floor(Math.random()*5) 
								if (rand == 0) {
									spriteSet = 6;
								}else if (rand == 1) {
									spriteSet = 12;
								}else {
									spriteSet = 0;
								}
								
                                player.curse = player.curse*(.25);
                                console.log(lvlComplete);
                                rTransition = 4;
                                roomDrawY = 0-(2*screenHeight+16);
                                console.log('loading');
                                player.keys = [];
                                //difficulty++;
                                buildLevel(difficulty);
                            }
                        },
                        draw:	function() {
                                    drawSprite(this.sprite[0], this.loc.x, this.loc.y);
                                },
                        diff: -1
        };
    }
	var mobs = [con_mob];
    
    {//base rooms
        var base_0 = {name:'base_0',    config:[[9,10],[7,8],[9,10],[7,8]], contents:[], obs:-1, discovered: false};
        var base_1 = {name:'base_1',    config:[[9,10],[],[],[]],           contents:[], obs:-1, discovered: false};
        var base_2 = {name:'base_2',    config:[[],[],[9,10],[]],           contents:[], obs:-1, discovered: false};
        var base_3 = {name:'base_3',    config:[[],[7,8],[],[]],            contents:[], obs:-1, discovered: false};
        var base_4 = {name:'base_4',    config:[[],[],[],[7,8]],            contents:[], obs:-1, discovered: false};
        var base_5 = {name:'base_5',    config:[[],[7,8],[],[7,8]],         contents:[], obs:-1, discovered: false};
        var base_6 = {name:'base_6',    config:[[9,10],[],[9,10],[]],       contents:[], obs:-1, discovered: false};
        var base_7 = {name:'base_7',    config:[[],[],[9,10],[7,8]],        contents:[], obs:-1, discovered: false};
        var base_8 = {name:'base_8',    config:[[],[7,8],[9,10],[]],        contents:[], obs:-1, discovered: false};
        var base_9 = {name:'base_9',    config:[[9,10],[7,8],[],[]],        contents:[], obs:-1, discovered: false};
        var base_10 = {name:'base_10',  config:[[9,10],[],[],[7,8]],        contents:[], obs:-1, discovered: false};
        var base_11 = {name:'base_11',  config:[[9,10],[7,8],[],[7,8]],     contents:[], obs:-1, discovered: false};
        var base_12 = {name:'base_12',  config:[[],[7,8],[9,10],[7,8]],     contents:[], obs:-1, discovered: false};
        var base_13 = {name:'base_13',  config:[[9,10],[7,8],[9,10],[]],    contents:[], obs:-1, discovered: false};
        var base_14 = {name:'base_14',  config:[[9,10],[],[9,10],[7,8]],    contents:[], obs:-1, discovered: false};
        
        var open_0 = {name:'open_0',    config:[[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17],[7,8],[9,10],[7,8]], contents:[], obs:-1, discovered: false};
        var open_1 = {name:'open_1',    config:[[9,10],[7,8],[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17],[7,8]], contents:[], obs:-1, discovered: false};
    }
    var empty = {name:'empty',          config:[[9,10],[7,8],[9,10],[7,8]], contents:[], obs:[], discovered: false};
    
	var rooms = [base_0,base_1,base_2,base_3,base_4,base_5,base_6,base_7,base_8,base_9,base_10,base_11,base_12,base_13,base_14,open_0,open_1];
	
    //input
	document.addEventListener('keydown', function(event) {
	  switch (event.keyCode) {
        case	74:	if (pressedKeys.indexOf('J')<0) {
						pressedKeys.push('J');
					}
					break;
        case    65: if (pressedKeys.indexOf('A')<0) {
                        pressedKeys.push('A');
                    }
                    break;
        case    87: if (pressedKeys.indexOf('W')<0) {
                        pressedKeys.push('W');
                    }
                    break;
        case    68: if (pressedKeys.indexOf('D')<0) {
                        pressedKeys.push('D');
                    }
                    break;
        case    83: if (pressedKeys.indexOf('S')<0) {
                        pressedKeys.push('S');
                    }
                    break;
        case    77: if (pressedKeys.indexOf('M')<0) {
                        pressedKeys.push('M');
                        if (paused == true) {
                            menu = false;
                        } else {
                            paused = true;
                            menu = true;
                            menuHeight = screenHeight-16;
                        }
                    }
                    break;
		case	32:	if (pressedKeys.indexOf('_')<0) {
                        if (player.spriit >= player.weapons[player.wepIndex].init_cost) {
                            player.attacking = true;
                            player.spirit = player.spirit-player.weapons[player.wepIndex].init_cost;
                        }
                        
						pressedKeys.push('_');
					}
					break;
      }
	}, false);
    
    document.addEventListener('keyup', function(event) {
	  switch (event.keyCode) {
        case	74:	pressedKeys.splice(pressedKeys.indexOf('J'),1);
                    break;
        case    65: pressedKeys.splice(pressedKeys.indexOf('A'),1);
                    break;
        case    87: pressedKeys.splice(pressedKeys.indexOf('W'),1);
                    break;
        case    68: pressedKeys.splice(pressedKeys.indexOf('D'),1);
                    break;
        case    83: pressedKeys.splice(pressedKeys.indexOf('S'),1);
                    break;
        case    77: pressedKeys.splice(pressedKeys.indexOf('M'),1);
                    break;
		case	32:	pressedKeys.splice(pressedKeys.indexOf('_'),1);
                    player.attacking = false;
                    break;			
      }
	}, false);
    
	
	
	
	
	
	
	
	//-----------------------------------------------------------------------------
	//-
	//-								  START
	//-
	//-----------------------------------------------------------------------------
    init();
    
    //start event loop
    setInterval(mainLoop, Math.floor(1000/60));
    
    //fps counter
    setInterval(function() {
        fps = frames;
        frames = 0;
    },1000);
    
    //control blinking
    setInterval(function() {
		//player.anim_index++;
		
        if (blink == true) {
            blink = false;
        } else {
            blink = true;
        }
    },250);
    
    //kick off EVERYTHING
    function init() {
        
        player.health = 10;
        player.maxHealth = 10;
        player.spirit = 10;
        player.maxSpirit = 10;
        player.curse = 0;
        
        player.x = 9*tileSize;
        player.y = 8*tileSize;
        player.dir = 2;
        player.strafe = false;
        player.moving = false;
        player.attacking = false;
        player.speed = 1;
        player.base_damage = 1;
        player.base_defense = 1;

        player.healthGen = 0;
        player.spiritGen = .1;
        player.curseGen = .0001;
        player.exp = 0;
        player.lvl = 0;
        
        player.augments = [];
        player.keys = [];
        
        player.anim_index = 0;
        player.animCounter = -1;
        
        player.wepIndex = 0;
        
        depth = -1;
        difficulty = 1;
        
        buildLevel(difficulty);
        prevLvl = JSON.parse(JSON.stringify(currLvl));
        
    }
    
    //build room config from .tmx file
    function buildConfig(config_name) {
        config_name = 'assets/'+config_name+'.tmx';
        var tiledXML;
		var tiled;
		var background,collision,overlap;
		var newmap = [];
		var rawFile = new XMLHttpRequest();
		rawFile.open('GET', config_name, false);
		rawFile.onreadystatechange = function () {
			if (rawFile.readyState === 4) {
				if (rawFile.status === 200 || rawFile.status == 0) {
					tiledXML = rawFile.responseText;
				}
			}
		}
		rawFile.send(null);
		tiledXML = $.parseXML(tiledXML);
		$tiled = $(tiledXML);
		$tiled = $tiled.find('data');
        
        background = $tiled[0].innerHTML;
		collision = $tiled[1].innerHTML;
		overlap = $tiled[2].innerHTML;
		
		background = background.split('\n');
		background.shift();
		background.pop();
		for (var i=0; i<background.length; i++) {
			background[i] = background[i].split(',');
			if (i!=background.length-1) {
				background[i].pop();
			}
			
		}
		for (var i=0; i<background.length; i++) {
			for (var j=0; j<background[i].length; j++) {
				background[i][j] = parseInt(background[i][j]);
			}
		}
		newmap.push(background);
		
		collision = collision.split('\n');
		collision.shift();
		collision.pop();
		for (var i=0; i<collision.length; i++) {
			collision[i] = collision[i].split(',');
			if (i!=collision.length-1) {
				collision[i].pop();
			}
		}
		for (var i=0; i<collision.length; i++) {
			for (var j=0; j<collision[i].length; j++) {
				collision[i][j] = parseInt(collision[i][j]);
			}
		}
		newmap.push(collision);
		overlap = overlap.split('\n');
		overlap.shift();
		overlap.pop();
		for (var i=0; i<overlap.length; i++) {
			overlap[i] = overlap[i].split(',');
			if (i!=overlap.length-1) {
				overlap[i].pop();
			}
		}
		for (var i=0; i<overlap.length; i++) {
			for (var j=0; j<overlap[i].length; j++) {
				overlap[i][j] = parseInt(overlap[i][j]);
			}
		}
		newmap.push(overlap);
		return newmap;
    }
    
    //load a room from a .tmx file
	function buildTiled(map_name) {
        map_name = 'assets/'+map_name;
        var tiledXML;
		var tiled;
		var background,collision,overlap;
		var newmap = [];
		var rawFile = new XMLHttpRequest();
		rawFile.open('GET', map_name, false);
		rawFile.onreadystatechange = function () {
			if (rawFile.readyState === 4) {
				if (rawFile.status === 200 || rawFile.status == 0) {
					tiledXML = rawFile.responseText;
				}
			}
		}
		rawFile.send(null);
		tiledXML = $.parseXML(tiledXML);
		$tiled = $(tiledXML);
		$tiled = $tiled.find('data');
		
		background = $tiled[0].innerHTML;
		collision = $tiled[1].innerHTML;
		overlap = $tiled[2].innerHTML;
		
		background = background.split('\n');
		background.shift();
		background.pop();
		for (var i=0; i<background.length; i++) {
			background[i] = background[i].split(',');
			if (i!=background.length-1) {
				background[i].pop();
			}
			
		}
		for (var i=0; i<background.length; i++) {
			for (var j=0; j<background[i].length; j++) {
				background[i][j] = parseInt(background[i][j]);
			}
		}
		newmap.push(background);
		
		collision = collision.split('\n');
		collision.shift();
		collision.pop();
		for (var i=0; i<collision.length; i++) {
			collision[i] = collision[i].split(',');
			if (i!=collision.length-1) {
				collision[i].pop();
			}
		}
		for (var i=0; i<collision.length; i++) {
			for (var j=0; j<collision[i].length; j++) {
				collision[i][j] = parseInt(collision[i][j]);
			}
		}
		newmap.push(collision);
		overlap = overlap.split('\n');
		overlap.shift();
		overlap.pop();
		for (var i=0; i<overlap.length; i++) {
			overlap[i] = overlap[i].split(',');
			if (i!=overlap.length-1) {
				overlap[i].pop();
			}
		}
		for (var i=0; i<overlap.length; i++) {
			for (var j=0; j<overlap[i].length; j++) {
				overlap[i][j] = parseInt(overlap[i][j]);
			}
		}
		newmap.push(overlap);
		//console.log(map);
		loadLevel(newmap);
	}
	
    //debug print the level map
    function printMap() {
        var row = '';
        console.log('Map:');
        for (var i=0; i<map.length; i++) {
            row = '';
            for (var j=0; j<map[i].length; j++) {
                if (map[i][j] == 0) {
                    row+=' 0';
                } else {
                    row+=' '+map[i][j].name;
                }
            }
            console.log(row);
        }
    }
    
    //generate a level
	function buildLevel(size, gen) {
        depth++;
		map = [ [0,0,0],
                [0,empty,0],
                [0,0,0]];
		mapLoc = {x:1, y:1};
        cards = [];
        var emptList = [];
        var rand;
        var i,j,k
        var seed = '';
        var genIndex = 0;
        var config;
        var minRooms = 3+size;
        var numRooms = 0;
        if (gen) {
            size = parseInt(gen.substring(0,gen.indexOf('e')));
            genIndex = gen.indexOf('e')+1;
        }
        seed+=size+'e';
        
        function expandMap(y, x) {
            //expand map if needed
            if (y == 0) {
                var newRow = [];
                for (c=0; c<map[0].length; c++) {
                    newRow.push(0);
                }
                map.unshift(newRow);
                mapLoc.y++;
                for (c=0; c<emptList.length; c++) {
                    emptList[c].y++;
                }
            }
            if (x == 0) {
                for (c=0; c<map.length; c++) {
                    map[c].unshift(0);
                }
                mapLoc.x++;
                for (c=0; c<emptList.length; c++) {
                    emptList[c].x++;
                }
            }
            if (y == map.length-1) {
                var newRow = [];
                for (c=0; c<map[0].length; c++) {
                    newRow.push(0);
                }
                map.push(newRow);
            }
            if (x == map[emptList[j].y].length-1) {
                for (c=0; c<map.length; c++) {
                    map[c].push(0);
                }
            }
        } 
        
        for (i=0; i<size; i++) {
            //build list of expandable rooms
            for (j=0; j<map.length; j++) {
                for (k=0; k<map[j].length; k++) {
                    if (JSON.stringify(map[j][k]) == JSON.stringify(empty) ||
                        JSON.stringify(map[j][k]) == JSON.stringify(base_1) ||
                        JSON.stringify(map[j][k]) == JSON.stringify(base_2) ||
                        JSON.stringify(map[j][k]) == JSON.stringify(base_3) ||
                        JSON.stringify(map[j][k]) == JSON.stringify(base_4)) {
                        emptList.push({x:k, y:j});
                    }
                }
            }
			
            //expand every empty room in list
            for (j=0; j<emptList.length; j++) {
                //check configs of surrounding rooms;
                var matchConfig = [];
                
                if (map[emptList[j].y-1][emptList[j].x] == 0) {   //above
                    matchConfig.push(2);
                } else {
                    matchConfig.push(map[emptList[j].y-1][emptList[j].x].config[2]);
                }
                if (map[emptList[j].y][emptList[j].x-1] == 0) {   //left
                    matchConfig.push(2);
                } else {
                    matchConfig.push(map[emptList[j].y][emptList[j].x-1].config[3]);
                }
                if (map[emptList[j].y+1][emptList[j].x] == 0) {   //below
                    matchConfig.push(2);
                } else {
                    matchConfig.push(map[emptList[j].y+1][emptList[j].x].config[0]);
                }
                if (map[emptList[j].y][emptList[j].x+1] == 0) {   //right
                    matchConfig.push(2);
                } else {
                    matchConfig.push(map[emptList[j].y][emptList[j].x+1].config[1]);
                }

                //build list of applicable rooms
                var appList = [];
                for (k=0; k<rooms.length; k++) {
                    //if (JSON.stringify(rooms[k].config) == JSON.stringify(matchConfig)) {
					if ((JSON.stringify(rooms[k].config[0]) == JSON.stringify(matchConfig[0]) || matchConfig[0] == 2) &&
						(JSON.stringify(rooms[k].config[1]) == JSON.stringify(matchConfig[1]) || matchConfig[1] == 2) &&
						(JSON.stringify(rooms[k].config[2]) == JSON.stringify(matchConfig[2]) || matchConfig[2] == 2) &&
						(JSON.stringify(rooms[k].config[3]) == JSON.stringify(matchConfig[3]) || matchConfig[3] == 2)) {
                        appList.push(JSON.parse(JSON.stringify(rooms[k])));
                    }
                }

                //pick a room
                if (gen) {
                    rand = parseInt(gen.charAt(genIndex));
                    genIndex++;
                } else {
                    rand = Math.floor(Math.random()*appList.length);
                }
                seed+=rand;
                map[emptList[j].y][emptList[j].x] = JSON.parse(JSON.stringify(appList[rand]));
                numRooms++;

                //create new empty's
                if (appList[rand].config[0].length > 0 && map[emptList[j].y-1][emptList[j].x] == 0) {
                    map[emptList[j].y-1][emptList[j].x] = JSON.parse(JSON.stringify(empty));
                    expandMap(emptList[j].y-1, emptList[j].x);
                }
                if (appList[rand].config[1].length > 0 && map[emptList[j].y][emptList[j].x-1] == 0) {
                    map[emptList[j].y][emptList[j].x-1] = JSON.parse(JSON.stringify(empty));
                    expandMap(emptList[j].y, emptList[j].x-1);
                }
                if (appList[rand].config[2].length > 0 && map[emptList[j].y+1][emptList[j].x] == 0) {
                    map[emptList[j].y+1][emptList[j].x] = JSON.parse(JSON.stringify(empty));
                    expandMap(emptList[j].y+1, emptList[j].x);
                }
                if (appList[rand].config[3].length > 0 && map[emptList[j].y][emptList[j].x+1] == 0) {
                    map[emptList[j].y][emptList[j].x+1] = JSON.parse(JSON.stringify(empty));
                    expandMap(emptList[j].y, emptList[j].x+1);
                }
              
            }
            emptList = [];
            if (numRooms < minRooms) {
                i--;
            }
        }
        
        //cap off the remaining empties
        //build list of remaining empties
        for (j=0; j<map.length; j++) {
            for (k=0; k<map[j].length; k++) {
                if (JSON.stringify(map[j][k]) == JSON.stringify(empty)) {
                    emptList.push({x:k, y:j});
                }
            }
        }
        
        for (j=0; j<emptList.length; j++) {
            if (JSON.stringify(map[emptList[j].y][emptList[j].x]) == JSON.stringify(empty)) {
                var capConfig = [];
        
                if (map[emptList[j].y-1][emptList[j].x] == 0) {   //above
                    capConfig.push([]);
                } else {
                    capConfig.push(map[emptList[j].y-1][emptList[j].x].config[2]);
                }
                if (map[emptList[j].y][emptList[j].x-1] == 0) {   //left
                    capConfig.push([]);
                } else {
                    capConfig.push(map[emptList[j].y][emptList[j].x-1].config[3]);
                }
                if (map[emptList[j].y+1][emptList[j].x] == 0) {   //below
                    capConfig.push([]);
                } else {
                    capConfig.push(map[emptList[j].y+1][emptList[j].x].config[0]);
                }
                if (map[emptList[j].y][emptList[j].x+1] == 0) {   //right
                    capConfig.push([]);
                } else {
                    capConfig.push(map[emptList[j].y][emptList[j].x+1].config[1]);
                }
                
                //build list of applicable rooms
                var capList = [];
                for (k=0; k<rooms.length; k++) {
                    //if (JSON.stringify(rooms[k].config) == JSON.stringify(matchConfig)) {
					if ((JSON.stringify(rooms[k].config[0]) == JSON.stringify(capConfig[0])) &&
						(JSON.stringify(rooms[k].config[1]) == JSON.stringify(capConfig[1])) &&
						(JSON.stringify(rooms[k].config[2]) == JSON.stringify(capConfig[2])) &&
						(JSON.stringify(rooms[k].config[3]) == JSON.stringify(capConfig[3]))) {
                        capList.push(JSON.parse(JSON.stringify(rooms[k])));
                    }
                }
                //pick a room
                if (gen) {
                    rand = parseInt(gen.charAt(genIndex));
                    genIndex++;
                } else {
                    rand = Math.floor(Math.random()*capList.length);
                }
                seed+=rand;
                map[emptList[j].y][emptList[j].x] = JSON.parse(JSON.stringify(capList[rand]));
                numRooms++;
            }
        }
        
        //put goal in map
        var rList = [];
        for (i=0; i<map.length; i++) {
            for (j=0; j<map[i].length; j++) {
                if (map[i][j]!=0 && !(i == mapLoc.y && j == mapLoc.x)) {
                    rList.push({x: j, y: i});
                }
            }
        }
        //console.log(rList);
        if (gen) {
            rand = gen.charAt(genIndex);
            genIndex++;
        } else {
            rand = Math.floor(Math.random()*rList.length);
        }
        seed+=rand;

        map[rList[rand].y][rList[rand].x].contents.push($.extend({}, con_goal));
        map[rList[rand].y][rList[rand].x].obs = buildConfig('config_goal');
		map[rList[rand].y][rList[rand].x].contents[0].diff = Math.ceil((rList.length-1)/2);
		goalTile.x = rList[rand].x;
		goalTile.y = rList[rand].y;
		var numKeys = Math.ceil((rList.length-1)/2);
		rList.splice(rand, 1);
        
		//put in keys
		for (i=0; i<numKeys; i++) {
			if (gen) {
				rand = gen.charAt(genIndex);
				genIndex++;
			} else {
				rand = Math.floor(Math.random()*rList.length);
			}
			seed+=rand;
			map[rList[rand].y][rList[rand].x].contents.push($.extend(true, {}, con_key));
			rList.splice(rand,1);
			
		}
		//put mobs in rooms
		for (i=0; i<map.length; i++) {
			for (j=0; j<map[i].length; j++) {
				if (map[i][j] != 0) {
					if (gen) {
						rand = gen.charAt(genIndex);
						genIndex++;
					} else {
						rand = Math.floor(Math.random()*2);
					}
					seed+=rand;
					if (rand == 0) {
						if (gen) {
							rand = gen.charAt(genIndex);
							genIndex++;
						} else {
							rand = Math.floor(Math.random()*mobs.length);
						}
						seed+=rand;
						map[i][j].contents.push($.extend(true, {}, mobs[rand]));
					}
				}
			}
		}
        //put powerups in rooms
        for (i=0; i<map.length; i++) {
            for (j=0; j<map[i].length; j++) {
                if (map[i][j] != 0 && !(i == mapLoc.y && j == mapLoc.x)) {
                    if (map[i][j].contents.length < 1) {
                        if (gen) {
                            rand = gen.charAt(genIndex);
                            genIndex++;
                        } else {
                            rand = Math.floor(Math.random()*2);
                        }
                        seed+=rand;
                        if (rand == 0) {
                            if (gen) {
                                rand = gen.charAt(genIndex);
                                genIndex++;
                            } else {
                                rand = Math.floor(Math.random()*augments.length);
                            }
                            seed+=rand;
                            map[i][j].contents.push($.extend(true, {}, con_aug));
                            map[i][j].obs = buildConfig('config_aug');
                            map[i][j].contents[map[i][j].contents.length-1].aug = rand;
                        }
                    } 
                }
            }
        }
        console.log(seed);
        minimap.update();
        player.x = 9*tileSize;
        player.y = 8*tileSize;
        //console.log(JSON.stringify(cards));
        
        //assign obstacle configs
        for (i=0; i<map.length; i++) {
			for (j=0; j<map[i].length; j++) {
                if (map[i][j] != 0 && map[i][j].obs == -1 && !(i == mapLoc.y && j == mapLoc.x)) {
                    if (gen) {
                        rand = gen.charAt(genIndex);
                        genIndex++;
                    } else {
                        rand = Math.floor(Math.random()*12);
                    }
                    seed+=rand;
                    
                    map[i][j].obs = buildConfig('config_'+rand);
                }
            }
        }
        
        buildTiled(map[mapLoc.y][mapLoc.x].name+'.tmx');
        lvlComplete = false;
	}
	
    //loads a level
    function loadLevel(level) {
		var rand;
        moves = 0;
        
		map[mapLoc.y][mapLoc.x].discovered = true;
		
        //insert the obstacle config
        if (map[mapLoc.y][mapLoc.x].obs != -1) {
			for (var k=0; k<3; k++) {
				for (var i=0; i<level[k].length; i++) {
					for (var j=0; j<level[k][i].length; j++) {
						if (map[mapLoc.y][mapLoc.x].obs[k][i][j] !=0) {
							level[k][i][j] = map[mapLoc.y][mapLoc.x].obs[k][i][j];
						}
					}
				}
			}
        }
        
		//build list of placeable spots
		var placeList = [];
		for (var i=0; i<level[1].length; i++) {
			for (var j=0; j<level[1][i].length; j++) {
				if (i>1 && i<level[1].length-1 && j>1 && j<level[1][i].length-1 && level[1][i][j] == 0) {
					placeList.push({x:j, y:i});
				}
			}
		}
		
        //move contents if needed
        for (var i=0; i<map[mapLoc.y][mapLoc.x].contents.length; i++) {
			if (map[mapLoc.y][mapLoc.x].contents[i].type == 'mob' && 
                map[mapLoc.y][mapLoc.x].contents[i].loc.x == -1 && map[mapLoc.y][mapLoc.x].contents[i].loc.y == -1 ||
                map[mapLoc.y][mapLoc.x].contents[i].loc.x < 16 && map[mapLoc.y][mapLoc.x].contents[i].loc.y < 16 ||
                map[mapLoc.y][mapLoc.x].contents[i].loc.x > screenWidth-16 && map[mapLoc.y][mapLoc.x].contents[i].loc.y > screenHeight-32) {
                
				rand = Math.floor(Math.random()*placeList.length);
				map[mapLoc.y][mapLoc.x].contents[i].loc.x = placeList[rand].x*tileSize;
				map[mapLoc.y][mapLoc.x].contents[i].loc.y = placeList[rand].y*tileSize;
			}
            if (map[mapLoc.y][mapLoc.x].contents[i].type == 'key' &&
                level[1][Math.floor(map[mapLoc.y][mapLoc.x].contents[i].loc.y/tileSize)][Math.floor(map[mapLoc.y][mapLoc.x].contents[i].loc.x/tileSize)] != 0) {
                
                rand = Math.floor(Math.random()*placeList.length);
				map[mapLoc.y][mapLoc.x].contents[i].loc.x = placeList[rand].x*tileSize;
				map[mapLoc.y][mapLoc.x].contents[i].loc.y = placeList[rand].y*tileSize;
            }
		}
        if (currLvl!=null) {
            prevLvl = JSON.parse(JSON.stringify(currLvl));
        }
        currLvl = JSON.parse(JSON.stringify(level));
		//console.log(JSON.stringify(map[mapLoc.y][mapLoc.x].contents));
    }
    
    //draw a sprite
	function drawSprite(sprite,x,y) {
        if (sprite+spriteSet == 28 && blink == true) {
            sprite = 60-spriteSet;
        }
        if (sprite+spriteSet == 92 && blink == true) {
            sprite = 124-spriteSet;
        }
        if (sprite+spriteSet == 27 && blink == true) {
            sprite = 59-spriteSet;
        }
        if (sprite+spriteSet == 123 && blink == true) {
            sprite = 155-spriteSet;
        }
        if (sprite+spriteSet == 224 && blink == true) {
            sprite = 256-spriteSet;
        }
		//sprite = sprite - spriteSet;
		var sX = Math.floor((sprite-1)/(sheetWidth/8))*8;
		var	sY = ((sprite-1)%(sheetWidth/8))*8;
        if (sprite == 560) {    //hardcoded for now b/c fuck everything
            ctx.drawImage(spriteSheet, 184,144,8,8,x,y,8,8);
        } else {
            ctx.drawImage(spriteSheet, sY,sX,8,8,x,y,8,8);
        }
	}
	
    //game window management
    function manageScreen() {
        if ($(window).width() < $(window).height()) {
			canvasWidth = $(window).width();
			canvasHeight = Math.floor((144/160)*($(window).width()));	
		} else {
			canvasHeight = $(window).height();
			canvasWidth = Math.floor((160/144)*($(window).height()));
		}
		canvas.style.top = JSON.stringify(($(window).height()/2)-(canvasHeight/2))+'px';
		canvas.style.left = JSON.stringify(($(window).width()/2)-(canvasWidth/2))+'px';
		canvas.height = JSON.stringify(canvasHeight);
		canvas.width = JSON.stringify(canvasWidth);
		canvas.style.position = 'absolute';
		ctx.imageSmoothingEnabled = false;
        scaleFactor = (canvasWidth/160);
    }
    
    //manage status bar and menu
    function menuSystem() {
        ctx.font="7px monospace";
        if (bannerCounter > -1) {
            bannerCounter++;
            if (bannerCounter > 120) {
                bannerCounter = -1;
            }
        }
        
        if (bannerCounter < 120 && bannerCounter > -1) {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, 64, 8);
            
            ctx.fillStyle = 'white';
            ctx.fillText('Depth: '+depth, 2, 6);
        }
        
        //pause screen
        if (paused == true) {
            if (menu == true) {
                if (menuHeight > 0) {
                    menuHeight = menuHeight -20;
                }
            } else {
                if (menu < screenHeight-16) {
                    menuHeight = menuHeight+20;
                }
                if (menuHeight >= screenHeight-16) {
                    paused = false;
                }
            }
            ctx.fillStyle = 'black';
            ctx.fillRect(Math.floor(screenWidth/2), menuHeight,Math.floor(screenWidth/2), Math.floor(screenHeight)-16-menuHeight);
            
            //stats
            //lvl dpt
            //dmg def
            //spd crs
            //hp  sp
            ctx.fillStyle = 'white';
            ctx.fillText('lvl: '+player.lvl,Math.floor(screenWidth/2)+4,menuHeight+24);
            ctx.fillText('depth: '+depth,Math.floor(screenWidth/2)+40,menuHeight+24);
            ctx.fillText('dmg: '+(player.base_damage).toFixed(2),Math.floor(screenWidth/2)+4,menuHeight+32);
            ctx.fillText('def: '+(player.base_defense).toFixed(2),Math.floor(screenWidth/2)+40,menuHeight+32);
            ctx.fillText('spd: '+(player.speed).toFixed(2),Math.floor(screenWidth/2)+4,menuHeight+40);
            ctx.fillText('crs: '+(player.curse).toFixed(2),Math.floor(screenWidth/2)+40,menuHeight+40);
            ctx.fillText('hpr: '+(100*player.healthGen).toFixed(2),Math.floor(screenWidth/2)+4,menuHeight+48);
            ctx.fillText('spr: '+(10*player.spiritGen).toFixed(2),Math.floor(screenWidth/2)+40,menuHeight+48);
            
            ctx.fillText('Augments:',Math.floor(screenWidth/2)+4,menuHeight+60);
            
            for (var i=0; i<player.augments.length; i++) {
                ctx.fillText(player.augments[i].name,Math.floor(screenWidth/2)+4,menuHeight+68+(i*8));
				ctx.fillText(player.augments[i].effectText,Math.floor(screenWidth/2)+40,menuHeight+68+(i*8));
            }
        
            //minimap
            for (var i=0; i<minimap.map.length; i++) {
                for(var j=0; j<minimap.map[i].length; j++) {
                    
                    //if (map[i][j].discovered == true) {
                        drawSprite(minimap.map[i][j],(8*j)+(4*8)-(mapLoc.x*8),menuHeight+(8*i)+(8*8)-(mapLoc.y*8));
                        if (i == goalTile.y && j == goalTile.x) {
                            drawSprite(1019, (8*j)+(4*8)-(mapLoc.x*8),menuHeight+(8*i)+(8*8)-(mapLoc.y*8));
                        }
                        if (i == mapLoc.y && j == mapLoc.x) {
                            drawSprite(1020, 4*8,menuHeight+(8*8));
                        }
                    //}
                }
            }
        }
        
        //status bar
        ctx.fillStyle = 'black';
        ctx.fillRect(0, screenHeight-16, screenWidth, screenHeight);
        
        ctx.fillStyle = 'white';
        ctx.fillText('HP[',0,screenHeight-10);
        for (var i=0; i<player.maxHealth; i++) {
            if (i<player.health) {
                ctx.fillText('|',(i+5)*2,screenHeight-10);
            } else {
                ctx.fillText(' ',(i+5)*2,screenHeight-10);
            }
        }
        ctx.fillText(']',(player.maxHealth+5.5)*2,screenHeight-10);
        
        ctx.fillText('SP[',0,screenHeight-2);
        for (var i=0; i<player.maxSpirit; i++) {
            if (i<player.spirit) {
                ctx.fillText('|',(i+5)*2,screenHeight-2);
            } else {
                ctx.fillText(' ',(i+5)*2,screenHeight-2);
            }
        }
        ctx.fillText(']',(player.maxSpirit+5.5)*2,screenHeight-2);
        
        ctx.fillText((player.x).toFixed(2)+','+(player.y).toFixed(2)+'; ', screenWidth-80, screenHeight-9);
        //ctx.fillText('p:'+points, 0, screenHeight-2);
        ctx.fillText(fps,screenWidth-15,screenHeight-9);
        drawSprite(550, screenWidth-80,screenHeight-9);
        ctx.fillText(':'+player.keys.length,screenWidth-72,screenHeight-2);
        
        ctx.fillText('XP[',screenWidth-50,screenHeight-2);
        for (var i=0; i<10; i++) {
            if (i<player.exp) {
                ctx.fillText('|',screenWidth-50+(i+5)*2,screenHeight-2);
            } else {
                ctx.fillText(' ',screenWidth-50+(i+5)*2,screenHeight-2);
            }
        }
        ctx.fillText(']: '+player.lvl,screenWidth-50+(10+5.5)*2,screenHeight-2);
        
        ctx.fillText('CR[',screenWidth-50,screenHeight-10);
        for (var i=0; i<10; i++) {
            if (i<player.curse) {
                ctx.fillText('|',screenWidth-50+(i+5)*2,screenHeight-10);
            } else {
                ctx.fillText(' ',screenWidth-50+(i+5)*2,screenHeight-10);
            }
        }
        ctx.fillText(']',screenWidth-50+(10+5.5)*2,screenHeight-10);
    }
    
    //main loop
	function mainLoop() {
        //console.log(lvlComplete);
        frames++;
        //update screen dimensions
        manageScreen();
        
        //scale game to canvas size
        ctx.scale(scaleFactor,scaleFactor);
        
        //clear the screen
        ctx.fillStyle = 'black';
        ctx.fillRect(0,0,screenWidth,screenHeight);
        
        if (player.health <=0 || player.curse >=10) {
            lvlComplete = true;
            player.health = 0;
            player.spirit = 0;
            player.curse = 0;
            player.keys = [];
            player.x = 0;
            player.y = 0;
            player.exp = 0;
            player.lvl = 0;
        }
        
        if (lvlComplete == false) {
            
            //check for room transitions
            if (Math.floor(player.y-player.speed) <= 1 && mapLoc.y-1 > 0) {
                rTransition = 0;
                roomDrawY = 0-screenHeight+16;
                mapLoc.y--;
                buildTiled(map[mapLoc.y][mapLoc.x].name+'.tmx');
                minimap.update();
            }
            if (Math.ceil(player.y+8+player.speed) >= screenHeight-16 && mapLoc.y+1 < map.length-1) {
                rTransition = 2;
                roomDrawY = screenHeight-16;
                mapLoc.y++;
                buildTiled(map[mapLoc.y][mapLoc.x].name+'.tmx');
                minimap.update();
            }
            if (Math.floor(player.x-player.speed) <= 1 && mapLoc.x-1 > 0) {
                rTransition = 1;
                roomDrawX = 0-screenWidth;
                mapLoc.x--;
                buildTiled(map[mapLoc.y][mapLoc.x].name+'.tmx');
                minimap.update();
            }
            if (Math.ceil(player.x+8+player.speed) >= screenWidth && mapLoc.x+1 < map[mapLoc.y].length-1) {
                rTransition = 3;
                roomDrawX = screenWidth;
                mapLoc.x++;
                buildTiled(map[mapLoc.y][mapLoc.x].name+'.tmx');
                minimap.update();
            }
			
            if (rTransition != -1) {
                if (rTransition == 0) {
                    player.y =  player.y +10;
                    roomDrawY = roomDrawY+10;
                    if (player.y >= screenHeight-28) {
                        player.y = screenHeight-28;
                    }
                    if (roomDrawY >=0) {
                        roomDrawY = 0;
                    }
                    if (roomDrawY == 0 && player.y == screenHeight-28){
                        rTransition = -1;
                    }
                }
                if (rTransition == 2) {
                    player.y =  player.y -10;
                    roomDrawY = roomDrawY-10;
                    if (player.y <= 9+player.speed) {
                        player.y = 9+player.speed;
                    }
                    if (roomDrawY <=0) {
                        roomDrawY = 0;
                    }
                    if (roomDrawY == 0 && player.y == 9+player.speed){
                        rTransition = -1;
                    }
                }
                if (rTransition == 1) {
                    player.x =  player.x +10;
                    roomDrawX = roomDrawX+10;
                    if (player.x >= screenWidth-9-player.speed) {
                        player.x = screenWidth-9-player.speed;
                    }
                    if (roomDrawX >= 0) {
                        roomDrawX = 0;
                    }
                    if (roomDrawX == 0 && player.x == screenWidth-9-player.speed) {
                        rTransition = -1;
                    }
                }
                if (rTransition == 3) {
                    player.x =  player.x -10;
                    roomDrawX = roomDrawX-10;
                    if (player.x <= 9+player.speed) {
                        player.x = 9+player.speed;
                    }
                    if (roomDrawX <= 0) {
                        roomDrawX = 0;
                    }
                    if (roomDrawX == 0 && player.x == 9+player.speed) {
                        rTransition = -1;
                    }
                }
                if (rTransition == 4) {
                    player.y =  player.y +10;
                    roomDrawY = roomDrawY+10;
                    if (player.y >= 8*tileSize) {
                        player.y = 8*tileSize;
                    }
                    if (roomDrawY >=0) {
                        roomDrawY = 0;
                    }
                    if (roomDrawY == 0 && player.y == 8*tileSize){
                        rTransition = -1;
                        bannerCounter = 0;
                    }
                    ctx.font="7px monospace";
                    ctx.fillStyle = 'white';
                    ctx.fillText('LOADING...', (screenWidth/2)-20, ((screenHeight-16)/2)+32);
                }
            }
            
            //render map
			//curr room background
            for (var i=0; i<currLvl[0].length; i++) {
                for (var j=0; j<currLvl[0][i].length; j++) {
                    if (currLvl[0][i][j] !=0) {
						drawSprite(currLvl[0][i][j]-spriteSet,roomDrawX+Math.floor((j*8)),roomDrawY+Math.floor((i*8)));
					}
                }
            }
            //prev room background
            if (rTransition != -1) {
                for (var i=0; i<prevLvl[0].length; i++) {
                    for (var j=0; j<prevLvl[0][i].length; j++) {
                        if (prevLvl[0][i][j] !=0) {
                            if (rTransition == 0) {
                                drawSprite(prevLvl[0][i][j]-spriteSet,roomDrawX+Math.floor((j*8)),roomDrawY+screenHeight-16+Math.floor((i*8)));
                            }
                            if (rTransition == 1) {
                                drawSprite(prevLvl[0][i][j]-spriteSet,roomDrawX+screenWidth+Math.floor((j*8)),roomDrawY+Math.floor((i*8)));
                            }
                            if (rTransition == 2) {
                                drawSprite(prevLvl[0][i][j]-spriteSet,roomDrawX+Math.floor((j*8)),roomDrawY-screenHeight+16+Math.floor((i*8)));
                            }
                            if (rTransition == 3) {
                                drawSprite(prevLvl[0][i][j]-spriteSet,roomDrawX-screenWidth+Math.floor((j*8)),roomDrawY+Math.floor((i*8)));
                            }
                        }
                    }
                }
            }
			
			//curr room collision
            for (var i=0; i<currLvl[1].length; i++) {
                for (var j=0; j<currLvl[1][i].length; j++) {
                    if (currLvl[1][i][j] !=0) {
						drawSprite(currLvl[1][i][j]-spriteSet,roomDrawX+Math.floor((j*8)),roomDrawY+Math.floor((i*8)));
					}
                }
            }
            //prev room collision
            if (rTransition != -1) {
                for (var i=0; i<prevLvl[1].length; i++) {
                    for (var j=0; j<prevLvl[1][i].length; j++) {
                        if (prevLvl[1][i][j] !=0) {
                            if (rTransition == 0) {
                                drawSprite(prevLvl[1][i][j]-spriteSet,roomDrawX+Math.floor((j*8)),roomDrawY+screenHeight-16+Math.floor((i*8)));
                            }
                            if (rTransition == 1) {
                                drawSprite(prevLvl[1][i][j]-spriteSet,roomDrawX+screenWidth+Math.floor((j*8)),roomDrawY+Math.floor((i*8)));
                            }
                            if (rTransition == 2) {
                                drawSprite(prevLvl[1][i][j]-spriteSet,roomDrawX+Math.floor((j*8)),roomDrawY-screenHeight+16+Math.floor((i*8)));
                            }
                            if (rTransition == 3) {
                                drawSprite(prevLvl[1][i][j]-spriteSet,roomDrawX-screenWidth+Math.floor((j*8)),roomDrawY+Math.floor((i*8)));
                            }
                        }
                    }
                }
            }

			//update the player and room contents
			if (paused == false && rTransition == -1) {	
                //update contents of room
                for (var i=0; i<map[mapLoc.y][mapLoc.x].contents.length; i++) {
                    map[mapLoc.y][mapLoc.x].contents[i].action();
                }
                
                player.update();    
			}
            
            //draw the contents of the room
            if (rTransition == -1) {
                for (var i=0; i<map[mapLoc.y][mapLoc.x].contents.length; i++) {
                    map[mapLoc.y][mapLoc.x].contents[i].draw();
                }
            }
                        
            ctx.fillStyle = 'red';
			ctx.fillRect(player.x,player.y,8,8);
            player.draw();
            
            //curr room overlap
            for (var i=0; i<currLvl[2].length; i++) {
                for (var j=0; j<currLvl[2][i].length; j++) {
                    if (currLvl[2][i][j] !=0) {
						drawSprite(currLvl[2][i][j]-spriteSet,roomDrawX+Math.floor((j*8)),roomDrawY+Math.floor((i*8)));
					}
                }
            }
            //prev room overlap
            if (rTransition != -1) {
                for (var i=0; i<prevLvl[2].length; i++) {
                    for (var j=0; j<prevLvl[2][i].length; j++) {
                        if (prevLvl[2][i][j] !=0) {
                            if (rTransition == 0) {
                                drawSprite(prevLvl[2][i][j]-spriteSet,roomDrawX+Math.floor((j*8)),roomDrawY+screenHeight-16+Math.floor((i*8)));
                            }
                            if (rTransition == 1) {
                                drawSprite(prevLvl[2][i][j]-spriteSet,roomDrawX+screenWidth+Math.floor((j*8)),roomDrawY+Math.floor((i*8)));
                            }
                            if (rTransition == 2) {
                                drawSprite(prevLvl[2][i][j]-spriteSet,roomDrawX+Math.floor((j*8)),roomDrawY-screenHeight+16+Math.floor((i*8)));
                            }
                            if (rTransition == 3) {
                                drawSprite(prevLvl[2][i][j]-spriteSet,roomDrawX-screenWidth+Math.floor((j*8)),roomDrawY+Math.floor((i*8)));
                            }
                        }
                    }
                }
            }
            
        } else {
			//render game over screen
            if (player.health <=0) {
                ctx.font="7px monospace";
                ctx.fillStyle = 'white';
                ctx.fillText('GAME OVER', (screenWidth/2)-20, ((screenHeight-16)/2));
                ctx.fillText('Press Space to Retry', (screenWidth/2)-40, ((screenHeight-16)/2)+8);
                
                if (pressedKeys.indexOf('_') > -1) {
                    init();
                }
            } else {
                
            }
        }
		//update/render menu
        menuSystem();
        ctx.scale((1/scaleFactor),(1/scaleFactor));
	}
</script>
</html>
